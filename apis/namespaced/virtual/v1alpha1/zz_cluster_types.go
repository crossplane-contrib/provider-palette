/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type BackupPolicyInitParameters struct {

	// (String) The ID of the backup location to use for the backup.
	// The ID of the backup location to use for the backup.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-palette/apis/namespaced/backup/v1alpha1.StorageLocation
	BackupLocationID *string `json:"backupLocationId,omitempty" tf:"backup_location_id,omitempty"`

	// Reference to a StorageLocation in backup to populate backupLocationId.
	// +kubebuilder:validation:Optional
	BackupLocationIDRef *v1.NamespacedReference `json:"backupLocationIdRef,omitempty" tf:"-"`

	// Selector for a StorageLocation in backup to populate backupLocationId.
	// +kubebuilder:validation:Optional
	BackupLocationIDSelector *v1.NamespacedSelector `json:"backupLocationIdSelector,omitempty" tf:"-"`

	// (Set of String) The list of cluster UIDs to include in the backup. If include_all_clusters is set to true, then all clusters will be included.
	// The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
	// +listType=set
	ClusterUids []*string `json:"clusterUids,omitempty" tf:"cluster_uids,omitempty"`

	// (Number) The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
	// The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
	ExpiryInHour *float64 `json:"expiryInHour,omitempty" tf:"expiry_in_hour,omitempty"`

	// (Boolean) Whether to include all clusters in the backup. If set to false, only the clusters specified in cluster_uids will be included.
	// Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
	IncludeAllClusters *bool `json:"includeAllClusters,omitempty" tf:"include_all_clusters,omitempty"`

	// (Boolean) Indicates whether to include cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the include_cluster_resources attribute will be deprecated, and a new attribute, include_cluster_resources_mode, will be introduced.)
	// Indicates whether to include cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the include_cluster_resources attribute will be deprecated, and a new attribute, include_cluster_resources_mode, will be introduced.)
	IncludeClusterResources *bool `json:"includeClusterResources,omitempty" tf:"include_cluster_resources,omitempty"`

	// (String) Specifies whether to include the cluster resources in the backup. Supported values are always, never, and auto.
	// Specifies whether to include the cluster resources in the backup. Supported values are `always`, `never`, and `auto`.
	IncludeClusterResourcesMode *string `json:"includeClusterResourcesMode,omitempty" tf:"include_cluster_resources_mode,omitempty"`

	// (Boolean) Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
	// Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
	IncludeDisks *bool `json:"includeDisks,omitempty" tf:"include_disks,omitempty"`

	// (Block List) The namespaces for the cluster. (see below for nested schema)
	// The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
	// +listType=set
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// -.
	// Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to 0 1 * * *.
	// The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
	Schedule *string `json:"schedule,omitempty" tf:"schedule,omitempty"`
}

type BackupPolicyObservation struct {

	// (String) The ID of the backup location to use for the backup.
	// The ID of the backup location to use for the backup.
	BackupLocationID *string `json:"backupLocationId,omitempty" tf:"backup_location_id,omitempty"`

	// (Set of String) The list of cluster UIDs to include in the backup. If include_all_clusters is set to true, then all clusters will be included.
	// The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
	// +listType=set
	ClusterUids []*string `json:"clusterUids,omitempty" tf:"cluster_uids,omitempty"`

	// (Number) The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
	// The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
	ExpiryInHour *float64 `json:"expiryInHour,omitempty" tf:"expiry_in_hour,omitempty"`

	// (Boolean) Whether to include all clusters in the backup. If set to false, only the clusters specified in cluster_uids will be included.
	// Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
	IncludeAllClusters *bool `json:"includeAllClusters,omitempty" tf:"include_all_clusters,omitempty"`

	// (Boolean) Indicates whether to include cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the include_cluster_resources attribute will be deprecated, and a new attribute, include_cluster_resources_mode, will be introduced.)
	// Indicates whether to include cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the include_cluster_resources attribute will be deprecated, and a new attribute, include_cluster_resources_mode, will be introduced.)
	IncludeClusterResources *bool `json:"includeClusterResources,omitempty" tf:"include_cluster_resources,omitempty"`

	// (String) Specifies whether to include the cluster resources in the backup. Supported values are always, never, and auto.
	// Specifies whether to include the cluster resources in the backup. Supported values are `always`, `never`, and `auto`.
	IncludeClusterResourcesMode *string `json:"includeClusterResourcesMode,omitempty" tf:"include_cluster_resources_mode,omitempty"`

	// (Boolean) Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
	// Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
	IncludeDisks *bool `json:"includeDisks,omitempty" tf:"include_disks,omitempty"`

	// (Block List) The namespaces for the cluster. (see below for nested schema)
	// The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
	// +listType=set
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// -.
	// Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to 0 1 * * *.
	// The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
	Schedule *string `json:"schedule,omitempty" tf:"schedule,omitempty"`
}

type BackupPolicyParameters struct {

	// (String) The ID of the backup location to use for the backup.
	// The ID of the backup location to use for the backup.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-palette/apis/namespaced/backup/v1alpha1.StorageLocation
	// +kubebuilder:validation:Optional
	BackupLocationID *string `json:"backupLocationId,omitempty" tf:"backup_location_id,omitempty"`

	// Reference to a StorageLocation in backup to populate backupLocationId.
	// +kubebuilder:validation:Optional
	BackupLocationIDRef *v1.NamespacedReference `json:"backupLocationIdRef,omitempty" tf:"-"`

	// Selector for a StorageLocation in backup to populate backupLocationId.
	// +kubebuilder:validation:Optional
	BackupLocationIDSelector *v1.NamespacedSelector `json:"backupLocationIdSelector,omitempty" tf:"-"`

	// (Set of String) The list of cluster UIDs to include in the backup. If include_all_clusters is set to true, then all clusters will be included.
	// The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
	// +kubebuilder:validation:Optional
	// +listType=set
	ClusterUids []*string `json:"clusterUids,omitempty" tf:"cluster_uids,omitempty"`

	// (Number) The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
	// The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
	// +kubebuilder:validation:Optional
	ExpiryInHour *float64 `json:"expiryInHour" tf:"expiry_in_hour,omitempty"`

	// (Boolean) Whether to include all clusters in the backup. If set to false, only the clusters specified in cluster_uids will be included.
	// Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
	// +kubebuilder:validation:Optional
	IncludeAllClusters *bool `json:"includeAllClusters,omitempty" tf:"include_all_clusters,omitempty"`

	// (Boolean) Indicates whether to include cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the include_cluster_resources attribute will be deprecated, and a new attribute, include_cluster_resources_mode, will be introduced.)
	// Indicates whether to include cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the include_cluster_resources attribute will be deprecated, and a new attribute, include_cluster_resources_mode, will be introduced.)
	// +kubebuilder:validation:Optional
	IncludeClusterResources *bool `json:"includeClusterResources,omitempty" tf:"include_cluster_resources,omitempty"`

	// (String) Specifies whether to include the cluster resources in the backup. Supported values are always, never, and auto.
	// Specifies whether to include the cluster resources in the backup. Supported values are `always`, `never`, and `auto`.
	// +kubebuilder:validation:Optional
	IncludeClusterResourcesMode *string `json:"includeClusterResourcesMode,omitempty" tf:"include_cluster_resources_mode,omitempty"`

	// (Boolean) Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
	// Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
	// +kubebuilder:validation:Optional
	IncludeDisks *bool `json:"includeDisks,omitempty" tf:"include_disks,omitempty"`

	// (Block List) The namespaces for the cluster. (see below for nested schema)
	// The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
	// +kubebuilder:validation:Optional
	// +listType=set
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// -.
	// Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// (String) The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to 0 1 * * *.
	// The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
	// +kubebuilder:validation:Optional
	Schedule *string `json:"schedule" tf:"schedule,omitempty"`
}

type CloudConfigInitParameters struct {

	// (String)
	ChartName *string `json:"chartName,omitempty" tf:"chart_name,omitempty"`

	// (String)
	ChartRepo *string `json:"chartRepo,omitempty" tf:"chart_repo,omitempty"`

	// (String)
	ChartValues *string `json:"chartValues,omitempty" tf:"chart_values,omitempty"`

	// (String)
	ChartVersion *string `json:"chartVersion,omitempty" tf:"chart_version,omitempty"`

	// (String)
	K8SVersion *string `json:"k8sVersion,omitempty" tf:"k8s_version,omitempty"`
}

type CloudConfigObservation struct {

	// (String)
	ChartName *string `json:"chartName,omitempty" tf:"chart_name,omitempty"`

	// (String)
	ChartRepo *string `json:"chartRepo,omitempty" tf:"chart_repo,omitempty"`

	// (String)
	ChartValues *string `json:"chartValues,omitempty" tf:"chart_values,omitempty"`

	// (String)
	ChartVersion *string `json:"chartVersion,omitempty" tf:"chart_version,omitempty"`

	// (String)
	K8SVersion *string `json:"k8sVersion,omitempty" tf:"k8s_version,omitempty"`
}

type CloudConfigParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ChartName *string `json:"chartName,omitempty" tf:"chart_name,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ChartRepo *string `json:"chartRepo,omitempty" tf:"chart_repo,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ChartValues *string `json:"chartValues,omitempty" tf:"chart_values,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ChartVersion *string `json:"chartVersion,omitempty" tf:"chart_version,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	K8SVersion *string `json:"k8sVersion,omitempty" tf:"k8s_version,omitempty"`
}

type ClusterInitParameters struct {

	// (String) The setting to apply the cluster profile. DownloadAndInstall will download and install packs in one action. DownloadAndInstallLater will only download artifact and postpone install for later. Default value is DownloadAndInstall.
	// The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. `DownloadAndInstallLater` will only download artifact and postpone install for later. Default value is `DownloadAndInstall`.
	ApplySetting *string `json:"applySetting,omitempty" tf:"apply_setting,omitempty"`

	// (Block List, Max: 1) The backup policy for the cluster. If not specified, no backups will be taken. (see below for nested schema)
	// The backup policy for the cluster. If not specified, no backups will be taken.
	BackupPolicy []BackupPolicyInitParameters `json:"backupPolicy,omitempty" tf:"backup_policy,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	CloudConfig []CloudConfigInitParameters `json:"cloudConfig,omitempty" tf:"cloud_config,omitempty"`

	// (String)
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-palette/apis/namespaced/cluster/v1alpha1.Group
	ClusterGroupUID *string `json:"clusterGroupUid,omitempty" tf:"cluster_group_uid,omitempty"`

	// Reference to a Group in cluster to populate clusterGroupUid.
	// +kubebuilder:validation:Optional
	ClusterGroupUIDRef *v1.NamespacedReference `json:"clusterGroupUidRef,omitempty" tf:"-"`

	// Selector for a Group in cluster to populate clusterGroupUid.
	// +kubebuilder:validation:Optional
	ClusterGroupUIDSelector *v1.NamespacedSelector `json:"clusterGroupUidSelector,omitempty" tf:"-"`

	// (Block List) (see below for nested schema)
	ClusterProfile []ClusterProfileInitParameters `json:"clusterProfile,omitempty" tf:"cluster_profile,omitempty"`

	// (Block List) The RBAC binding for the cluster. (see below for nested schema)
	// The RBAC binding for the cluster.
	ClusterRbacBinding []ClusterRbacBindingInitParameters `json:"clusterRbacBinding,omitempty" tf:"cluster_rbac_binding,omitempty"`

	// (String) The context of the virtual cluster. Allowed values are project or tenant. Default is project. If  the project context is specified, the project name will sourced from the provider configuration parameter project_name.
	// The context of the virtual cluster. Allowed values are `project` or `tenant`. Default is `project`. If  the `project` context is specified, the project name will sourced from the provider configuration parameter [`project_name`](https://registry.io/providers/spectrocloud/spectrocloud/latest/docs#schema).
	Context *string `json:"context,omitempty" tf:"context,omitempty"`

	// (String) The description of the cluster. Default value is empty string.
	// The description of the cluster. Default value is empty string.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) If set to true, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.
	// If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.
	ForceDelete *bool `json:"forceDelete,omitempty" tf:"force_delete,omitempty"`

	// (Number) Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.
	// Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.
	ForceDeleteDelay *float64 `json:"forceDeleteDelay,omitempty" tf:"force_delete_delay,omitempty"`

	// (String)
	HostClusterUID *string `json:"hostClusterUid,omitempty" tf:"host_cluster_uid,omitempty"`

	// (String)
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List) The namespaces for the cluster. (see below for nested schema)
	// The namespaces for the cluster.
	Namespaces []NamespacesInitParameters `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// 01-02T15:04:05Z07:00
	// The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`
	OsPatchAfter *string `json:"osPatchAfter,omitempty" tf:"os_patch_after,omitempty"`

	// (Boolean) Whether to apply OS patch on boot. Default is false.
	// Whether to apply OS patch on boot. Default is `false`.
	OsPatchOnBoot *bool `json:"osPatchOnBoot,omitempty" tf:"os_patch_on_boot,omitempty"`

	// (String) Cron schedule for OS patching. This must be in the form of 0 0 * * *.
	// Cron schedule for OS patching. This must be in the form of `0 0 * * *`.
	OsPatchSchedule *string `json:"osPatchSchedule,omitempty" tf:"os_patch_schedule,omitempty"`

	// (Boolean) To pause and resume cluster state. Set to true to pause running cluster & false to resume it.
	// To pause and resume cluster state. Set to true to pause running cluster & false to resume it.
	PauseCluster *bool `json:"pauseCluster,omitempty" tf:"pause_cluster,omitempty"`

	// (Block List) (see below for nested schema)
	Resources []ResourcesInitParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Block List, Max: 1) The scan policy for the cluster. (see below for nested schema)
	// The scan policy for the cluster.
	ScanPolicy []ScanPolicyInitParameters `json:"scanPolicy,omitempty" tf:"scan_policy,omitempty"`

	// (Boolean) If true, the cluster will be created asynchronously. Default value is false.
	// If `true`, the cluster will be created asynchronously. Default value is `false`.
	SkipCompletion *bool `json:"skipCompletion,omitempty" tf:"skip_completion,omitempty"`

	// (Set of String) A list of tags to be applied to the cluster. Tags must be in the form of key:value.
	// A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ClusterObservation struct {

	// config for the cluster. This can be used to connect to the cluster using kubectl, With admin privilege.
	// Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.
	AdminKubeConfig *string `json:"adminKubeConfig,omitempty" tf:"admin_kube_config,omitempty"`

	// (String) The setting to apply the cluster profile. DownloadAndInstall will download and install packs in one action. DownloadAndInstallLater will only download artifact and postpone install for later. Default value is DownloadAndInstall.
	// The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. `DownloadAndInstallLater` will only download artifact and postpone install for later. Default value is `DownloadAndInstall`.
	ApplySetting *string `json:"applySetting,omitempty" tf:"apply_setting,omitempty"`

	// (Block List, Max: 1) The backup policy for the cluster. If not specified, no backups will be taken. (see below for nested schema)
	// The backup policy for the cluster. If not specified, no backups will be taken.
	BackupPolicy []BackupPolicyObservation `json:"backupPolicy,omitempty" tf:"backup_policy,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	CloudConfig []CloudConfigObservation `json:"cloudConfig,omitempty" tf:"cloud_config,omitempty"`

	// (String, Deprecated) ID of the cloud config used for the cluster. This cloud config must be of type azure.
	// ID of the cloud config used for the cluster. This cloud config must be of type `azure`.
	CloudConfigID *string `json:"cloudConfigId,omitempty" tf:"cloud_config_id,omitempty"`

	// (String)
	ClusterGroupUID *string `json:"clusterGroupUid,omitempty" tf:"cluster_group_uid,omitempty"`

	// (Block List) (see below for nested schema)
	ClusterProfile []ClusterProfileObservation `json:"clusterProfile,omitempty" tf:"cluster_profile,omitempty"`

	// (Block List) The RBAC binding for the cluster. (see below for nested schema)
	// The RBAC binding for the cluster.
	ClusterRbacBinding []ClusterRbacBindingObservation `json:"clusterRbacBinding,omitempty" tf:"cluster_rbac_binding,omitempty"`

	// (String) The context of the virtual cluster. Allowed values are project or tenant. Default is project. If  the project context is specified, the project name will sourced from the provider configuration parameter project_name.
	// The context of the virtual cluster. Allowed values are `project` or `tenant`. Default is `project`. If  the `project` context is specified, the project name will sourced from the provider configuration parameter [`project_name`](https://registry.io/providers/spectrocloud/spectrocloud/latest/docs#schema).
	Context *string `json:"context,omitempty" tf:"context,omitempty"`

	// (String) The description of the cluster. Default value is empty string.
	// The description of the cluster. Default value is empty string.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) If set to true, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.
	// If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.
	ForceDelete *bool `json:"forceDelete,omitempty" tf:"force_delete,omitempty"`

	// (Number) Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.
	// Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.
	ForceDeleteDelay *float64 `json:"forceDeleteDelay,omitempty" tf:"force_delete_delay,omitempty"`

	// (String)
	HostClusterUID *string `json:"hostClusterUid,omitempty" tf:"host_cluster_uid,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Kubeconfig for the cluster. This can be used to connect to the cluster using kubectl.
	// Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.
	Kubeconfig *string `json:"kubeconfig,omitempty" tf:"kubeconfig,omitempty"`

	// (List of Object) The location of the cluster. (see below for nested schema)
	// The location of the cluster.
	LocationConfig []LocationConfigObservation `json:"locationConfig,omitempty" tf:"location_config,omitempty"`

	// (String)
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List) The namespaces for the cluster. (see below for nested schema)
	// The namespaces for the cluster.
	Namespaces []NamespacesObservation `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// 01-02T15:04:05Z07:00
	// The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`
	OsPatchAfter *string `json:"osPatchAfter,omitempty" tf:"os_patch_after,omitempty"`

	// (Boolean) Whether to apply OS patch on boot. Default is false.
	// Whether to apply OS patch on boot. Default is `false`.
	OsPatchOnBoot *bool `json:"osPatchOnBoot,omitempty" tf:"os_patch_on_boot,omitempty"`

	// (String) Cron schedule for OS patching. This must be in the form of 0 0 * * *.
	// Cron schedule for OS patching. This must be in the form of `0 0 * * *`.
	OsPatchSchedule *string `json:"osPatchSchedule,omitempty" tf:"os_patch_schedule,omitempty"`

	// (Boolean) To pause and resume cluster state. Set to true to pause running cluster & false to resume it.
	// To pause and resume cluster state. Set to true to pause running cluster & false to resume it.
	PauseCluster *bool `json:"pauseCluster,omitempty" tf:"pause_cluster,omitempty"`

	// (Block List) (see below for nested schema)
	Resources []ResourcesObservation `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Block List, Max: 1) The scan policy for the cluster. (see below for nested schema)
	// The scan policy for the cluster.
	ScanPolicy []ScanPolicyObservation `json:"scanPolicy,omitempty" tf:"scan_policy,omitempty"`

	// (Boolean) If true, the cluster will be created asynchronously. Default value is false.
	// If `true`, the cluster will be created asynchronously. Default value is `false`.
	SkipCompletion *bool `json:"skipCompletion,omitempty" tf:"skip_completion,omitempty"`

	// (Set of String) A list of tags to be applied to the cluster. Tags must be in the form of key:value.
	// A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ClusterParameters struct {

	// (String) The setting to apply the cluster profile. DownloadAndInstall will download and install packs in one action. DownloadAndInstallLater will only download artifact and postpone install for later. Default value is DownloadAndInstall.
	// The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. `DownloadAndInstallLater` will only download artifact and postpone install for later. Default value is `DownloadAndInstall`.
	// +kubebuilder:validation:Optional
	ApplySetting *string `json:"applySetting,omitempty" tf:"apply_setting,omitempty"`

	// (Block List, Max: 1) The backup policy for the cluster. If not specified, no backups will be taken. (see below for nested schema)
	// The backup policy for the cluster. If not specified, no backups will be taken.
	// +kubebuilder:validation:Optional
	BackupPolicy []BackupPolicyParameters `json:"backupPolicy,omitempty" tf:"backup_policy,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CloudConfig []CloudConfigParameters `json:"cloudConfig,omitempty" tf:"cloud_config,omitempty"`

	// (String)
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-palette/apis/namespaced/cluster/v1alpha1.Group
	// +kubebuilder:validation:Optional
	ClusterGroupUID *string `json:"clusterGroupUid,omitempty" tf:"cluster_group_uid,omitempty"`

	// Reference to a Group in cluster to populate clusterGroupUid.
	// +kubebuilder:validation:Optional
	ClusterGroupUIDRef *v1.NamespacedReference `json:"clusterGroupUidRef,omitempty" tf:"-"`

	// Selector for a Group in cluster to populate clusterGroupUid.
	// +kubebuilder:validation:Optional
	ClusterGroupUIDSelector *v1.NamespacedSelector `json:"clusterGroupUidSelector,omitempty" tf:"-"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	ClusterProfile []ClusterProfileParameters `json:"clusterProfile,omitempty" tf:"cluster_profile,omitempty"`

	// (Block List) The RBAC binding for the cluster. (see below for nested schema)
	// The RBAC binding for the cluster.
	// +kubebuilder:validation:Optional
	ClusterRbacBinding []ClusterRbacBindingParameters `json:"clusterRbacBinding,omitempty" tf:"cluster_rbac_binding,omitempty"`

	// (String) The context of the virtual cluster. Allowed values are project or tenant. Default is project. If  the project context is specified, the project name will sourced from the provider configuration parameter project_name.
	// The context of the virtual cluster. Allowed values are `project` or `tenant`. Default is `project`. If  the `project` context is specified, the project name will sourced from the provider configuration parameter [`project_name`](https://registry.io/providers/spectrocloud/spectrocloud/latest/docs#schema).
	// +kubebuilder:validation:Optional
	Context *string `json:"context,omitempty" tf:"context,omitempty"`

	// (String) The description of the cluster. Default value is empty string.
	// The description of the cluster. Default value is empty string.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) If set to true, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.
	// If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.
	// +kubebuilder:validation:Optional
	ForceDelete *bool `json:"forceDelete,omitempty" tf:"force_delete,omitempty"`

	// (Number) Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.
	// Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.
	// +kubebuilder:validation:Optional
	ForceDeleteDelay *float64 `json:"forceDeleteDelay,omitempty" tf:"force_delete_delay,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	HostClusterUID *string `json:"hostClusterUid,omitempty" tf:"host_cluster_uid,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List) The namespaces for the cluster. (see below for nested schema)
	// The namespaces for the cluster.
	// +kubebuilder:validation:Optional
	Namespaces []NamespacesParameters `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// 01-02T15:04:05Z07:00
	// The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`
	// +kubebuilder:validation:Optional
	OsPatchAfter *string `json:"osPatchAfter,omitempty" tf:"os_patch_after,omitempty"`

	// (Boolean) Whether to apply OS patch on boot. Default is false.
	// Whether to apply OS patch on boot. Default is `false`.
	// +kubebuilder:validation:Optional
	OsPatchOnBoot *bool `json:"osPatchOnBoot,omitempty" tf:"os_patch_on_boot,omitempty"`

	// (String) Cron schedule for OS patching. This must be in the form of 0 0 * * *.
	// Cron schedule for OS patching. This must be in the form of `0 0 * * *`.
	// +kubebuilder:validation:Optional
	OsPatchSchedule *string `json:"osPatchSchedule,omitempty" tf:"os_patch_schedule,omitempty"`

	// (Boolean) To pause and resume cluster state. Set to true to pause running cluster & false to resume it.
	// To pause and resume cluster state. Set to true to pause running cluster & false to resume it.
	// +kubebuilder:validation:Optional
	PauseCluster *bool `json:"pauseCluster,omitempty" tf:"pause_cluster,omitempty"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Resources []ResourcesParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Block List, Max: 1) The scan policy for the cluster. (see below for nested schema)
	// The scan policy for the cluster.
	// +kubebuilder:validation:Optional
	ScanPolicy []ScanPolicyParameters `json:"scanPolicy,omitempty" tf:"scan_policy,omitempty"`

	// (Boolean) If true, the cluster will be created asynchronously. Default value is false.
	// If `true`, the cluster will be created asynchronously. Default value is `false`.
	// +kubebuilder:validation:Optional
	SkipCompletion *bool `json:"skipCompletion,omitempty" tf:"skip_completion,omitempty"`

	// (Set of String) A list of tags to be applied to the cluster. Tags must be in the form of key:value.
	// A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.
	// +kubebuilder:validation:Optional
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ClusterProfileInitParameters struct {

	// (String) The ID of this resource.
	// The ID of the cluster profile.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-palette/apis/namespaced/cluster/v1alpha1.Profile
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Reference to a Profile in cluster to populate id.
	// +kubebuilder:validation:Optional
	IDRef *v1.NamespacedReference `json:"idRef,omitempty" tf:"-"`

	// Selector for a Profile in cluster to populate id.
	// +kubebuilder:validation:Optional
	IDSelector *v1.NamespacedSelector `json:"idSelector,omitempty" tf:"-"`

	// (Block List) For packs of type spectro, helm, and manifest, at least one pack must be specified. (see below for nested schema)
	// For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
	Pack []PackInitParameters `json:"pack,omitempty" tf:"pack,omitempty"`

	// value pairs. For example: priority = "5".
	// A map of cluster profile variables, specified as key-value pairs. For example: `priority = "5"`.
	// +mapType=granular
	Variables map[string]*string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type ClusterProfileObservation struct {

	// (String) The ID of this resource.
	// The ID of the cluster profile.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List) For packs of type spectro, helm, and manifest, at least one pack must be specified. (see below for nested schema)
	// For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
	Pack []PackObservation `json:"pack,omitempty" tf:"pack,omitempty"`

	// value pairs. For example: priority = "5".
	// A map of cluster profile variables, specified as key-value pairs. For example: `priority = "5"`.
	// +mapType=granular
	Variables map[string]*string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type ClusterProfileParameters struct {

	// (String) The ID of this resource.
	// The ID of the cluster profile.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-palette/apis/namespaced/cluster/v1alpha1.Profile
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Reference to a Profile in cluster to populate id.
	// +kubebuilder:validation:Optional
	IDRef *v1.NamespacedReference `json:"idRef,omitempty" tf:"-"`

	// Selector for a Profile in cluster to populate id.
	// +kubebuilder:validation:Optional
	IDSelector *v1.NamespacedSelector `json:"idSelector,omitempty" tf:"-"`

	// (Block List) For packs of type spectro, helm, and manifest, at least one pack must be specified. (see below for nested schema)
	// For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
	// +kubebuilder:validation:Optional
	Pack []PackParameters `json:"pack,omitempty" tf:"pack,omitempty"`

	// value pairs. For example: priority = "5".
	// A map of cluster profile variables, specified as key-value pairs. For example: `priority = "5"`.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Variables map[string]*string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type ClusterRbacBindingInitParameters struct {

	// (String) The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	// The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Map of String) The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'. Must include 'name' and 'kind' fields.
	// The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'. Must include 'name' and 'kind' fields.
	// +mapType=granular
	Role map[string]*string `json:"role,omitempty" tf:"role,omitempty"`

	// (Block List) (see below for nested schema)
	Subjects []SubjectsInitParameters `json:"subjects,omitempty" tf:"subjects,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ClusterRbacBindingObservation struct {

	// (String) The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	// The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Map of String) The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'. Must include 'name' and 'kind' fields.
	// The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'. Must include 'name' and 'kind' fields.
	// +mapType=granular
	Role map[string]*string `json:"role,omitempty" tf:"role,omitempty"`

	// (Block List) (see below for nested schema)
	Subjects []SubjectsObservation `json:"subjects,omitempty" tf:"subjects,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ClusterRbacBindingParameters struct {

	// (String) The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	// The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Map of String) The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'. Must include 'name' and 'kind' fields.
	// The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'. Must include 'name' and 'kind' fields.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Role map[string]*string `json:"role,omitempty" tf:"role,omitempty"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Subjects []SubjectsParameters `json:"subjects,omitempty" tf:"subjects,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type LocationConfigInitParameters struct {
}

type LocationConfigObservation struct {

	// (String)
	CountryCode *string `json:"countryCode,omitempty" tf:"country_code,omitempty"`

	// (String)
	CountryName *string `json:"countryName,omitempty" tf:"country_name,omitempty"`

	// (Number)
	Latitude *float64 `json:"latitude,omitempty" tf:"latitude,omitempty"`

	// (Number)
	Longitude *float64 `json:"longitude,omitempty" tf:"longitude,omitempty"`

	// (String)
	RegionCode *string `json:"regionCode,omitempty" tf:"region_code,omitempty"`

	// (String)
	RegionName *string `json:"regionName,omitempty" tf:"region_name,omitempty"`
}

type LocationConfigParameters struct {
}

type ManifestInitParameters struct {

	// (String) The content of the manifest. The content is the YAML content of the manifest.
	// The content of the manifest. The content is the YAML content of the manifest.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// (String)
	// The name of the manifest. The name must be unique within the pack.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ManifestObservation struct {

	// (String) The content of the manifest. The content is the YAML content of the manifest.
	// The content of the manifest. The content is the YAML content of the manifest.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// (String)
	// The name of the manifest. The name must be unique within the pack.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The unique identifier of the pack. The value can be looked up using the spectrocloud_pack data source. This value is required if the pack type is spectro and for helm if the chart is from a public helm registry. If not provided, all of name, tag, and registry_uid must be specified to resolve the pack UID internally.
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type ManifestParameters struct {

	// (String) The content of the manifest. The content is the YAML content of the manifest.
	// The content of the manifest. The content is the YAML content of the manifest.
	// +kubebuilder:validation:Optional
	Content *string `json:"content" tf:"content,omitempty"`

	// (String)
	// The name of the manifest. The name must be unique within the pack.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type NamespacesInitParameters struct {

	// (String)
	// Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Map of String) Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, {cpu_cores: '2', memory_MiB: '2048', gpu_limit: '1', gpu_provider: 'nvidia'}
	// Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu_limit: '1', gpu_provider: 'nvidia'}`
	// +mapType=granular
	ResourceAllocation map[string]*string `json:"resourceAllocation,omitempty" tf:"resource_allocation,omitempty"`
}

type NamespacesObservation struct {

	// (String)
	// Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Map of String) Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, {cpu_cores: '2', memory_MiB: '2048', gpu_limit: '1', gpu_provider: 'nvidia'}
	// Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu_limit: '1', gpu_provider: 'nvidia'}`
	// +mapType=granular
	ResourceAllocation map[string]*string `json:"resourceAllocation,omitempty" tf:"resource_allocation,omitempty"`
}

type NamespacesParameters struct {

	// (String)
	// Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (Map of String) Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, {cpu_cores: '2', memory_MiB: '2048', gpu_limit: '1', gpu_provider: 'nvidia'}
	// Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu_limit: '1', gpu_provider: 'nvidia'}`
	// +kubebuilder:validation:Optional
	// +mapType=granular
	ResourceAllocation map[string]*string `json:"resourceAllocation" tf:"resource_allocation,omitempty"`
}

type PackInitParameters struct {

	// (Block List) (see below for nested schema)
	Manifest []ManifestInitParameters `json:"manifest,omitempty" tf:"manifest,omitempty"`

	// (String)
	// The name of the pack. The name must be unique within the cluster profile.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// readable name of the registry. This attribute can be used instead of registry_uid for better readability. If uid is not provided, this field can be used along with name and tag to resolve the pack UID internally. Either registry_uid or registry_name can be specified, but not both.
	// The registry name of the pack. The registry name is the human-readable name of the registry. This attribute can be used instead of `registry_uid` for better readability. If `uid` is not provided, this field can be used along with `name` and `tag` to resolve the pack UID internally. Either `registry_uid` or `registry_name` can be specified, but not both.
	RegistryName *string `json:"registryName,omitempty" tf:"registry_name,omitempty"`

	// (String) The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name. If uid is not provided, this field is required along with name and tag to resolve the pack UID internally. Either registry_uid or registry_name can be specified, but not both.
	// The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name. If `uid` is not provided, this field is required along with `name` and `tag` to resolve the pack UID internally. Either `registry_uid` or `registry_name` can be specified, but not both.
	RegistryUID *string `json:"registryUid,omitempty" tf:"registry_uid,omitempty"`

	// (String) The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is spectro or helm. If uid is not provided, this field is required along with name and registry_uid (or registry_name) to resolve the pack UID internally.
	// The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`. If `uid` is not provided, this field is required along with `name` and `registry_uid` (or `registry_name`) to resolve the pack UID internally.
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) The unique identifier of the pack. The value can be looked up using the spectrocloud_pack data source. This value is required if the pack type is spectro and for helm if the chart is from a public helm registry. If not provided, all of name, tag, and registry_uid must be specified to resolve the pack UID internally.
	// The unique identifier of the pack. The value can be looked up using the [`spectrocloud_pack`](https://registry.io/providers/spectrocloud/spectrocloud/latest/docs/data-sources/pack) data source. This value is required if the pack type is `spectro` and for `helm` if the chart is from a public helm registry. If not provided, all of `name`, `tag`, and `registry_uid` must be specified to resolve the pack UID internally.
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`

	// (String) The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
	// The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
	Values *string `json:"values,omitempty" tf:"values,omitempty"`
}

type PackObservation struct {

	// (Block List) (see below for nested schema)
	Manifest []ManifestObservation `json:"manifest,omitempty" tf:"manifest,omitempty"`

	// (String)
	// The name of the pack. The name must be unique within the cluster profile.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// readable name of the registry. This attribute can be used instead of registry_uid for better readability. If uid is not provided, this field can be used along with name and tag to resolve the pack UID internally. Either registry_uid or registry_name can be specified, but not both.
	// The registry name of the pack. The registry name is the human-readable name of the registry. This attribute can be used instead of `registry_uid` for better readability. If `uid` is not provided, this field can be used along with `name` and `tag` to resolve the pack UID internally. Either `registry_uid` or `registry_name` can be specified, but not both.
	RegistryName *string `json:"registryName,omitempty" tf:"registry_name,omitempty"`

	// (String) The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name. If uid is not provided, this field is required along with name and tag to resolve the pack UID internally. Either registry_uid or registry_name can be specified, but not both.
	// The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name. If `uid` is not provided, this field is required along with `name` and `tag` to resolve the pack UID internally. Either `registry_uid` or `registry_name` can be specified, but not both.
	RegistryUID *string `json:"registryUid,omitempty" tf:"registry_uid,omitempty"`

	// (String) The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is spectro or helm. If uid is not provided, this field is required along with name and registry_uid (or registry_name) to resolve the pack UID internally.
	// The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`. If `uid` is not provided, this field is required along with `name` and `registry_uid` (or `registry_name`) to resolve the pack UID internally.
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) The unique identifier of the pack. The value can be looked up using the spectrocloud_pack data source. This value is required if the pack type is spectro and for helm if the chart is from a public helm registry. If not provided, all of name, tag, and registry_uid must be specified to resolve the pack UID internally.
	// The unique identifier of the pack. The value can be looked up using the [`spectrocloud_pack`](https://registry.io/providers/spectrocloud/spectrocloud/latest/docs/data-sources/pack) data source. This value is required if the pack type is `spectro` and for `helm` if the chart is from a public helm registry. If not provided, all of `name`, `tag`, and `registry_uid` must be specified to resolve the pack UID internally.
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`

	// (String) The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
	// The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
	Values *string `json:"values,omitempty" tf:"values,omitempty"`
}

type PackParameters struct {

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Manifest []ManifestParameters `json:"manifest,omitempty" tf:"manifest,omitempty"`

	// (String)
	// The name of the pack. The name must be unique within the cluster profile.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// readable name of the registry. This attribute can be used instead of registry_uid for better readability. If uid is not provided, this field can be used along with name and tag to resolve the pack UID internally. Either registry_uid or registry_name can be specified, but not both.
	// The registry name of the pack. The registry name is the human-readable name of the registry. This attribute can be used instead of `registry_uid` for better readability. If `uid` is not provided, this field can be used along with `name` and `tag` to resolve the pack UID internally. Either `registry_uid` or `registry_name` can be specified, but not both.
	// +kubebuilder:validation:Optional
	RegistryName *string `json:"registryName,omitempty" tf:"registry_name,omitempty"`

	// (String) The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name. If uid is not provided, this field is required along with name and tag to resolve the pack UID internally. Either registry_uid or registry_name can be specified, but not both.
	// The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name. If `uid` is not provided, this field is required along with `name` and `tag` to resolve the pack UID internally. Either `registry_uid` or `registry_name` can be specified, but not both.
	// +kubebuilder:validation:Optional
	RegistryUID *string `json:"registryUid,omitempty" tf:"registry_uid,omitempty"`

	// (String) The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is spectro or helm. If uid is not provided, this field is required along with name and registry_uid (or registry_name) to resolve the pack UID internally.
	// The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`. If `uid` is not provided, this field is required along with `name` and `registry_uid` (or `registry_name`) to resolve the pack UID internally.
	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) The unique identifier of the pack. The value can be looked up using the spectrocloud_pack data source. This value is required if the pack type is spectro and for helm if the chart is from a public helm registry. If not provided, all of name, tag, and registry_uid must be specified to resolve the pack UID internally.
	// The unique identifier of the pack. The value can be looked up using the [`spectrocloud_pack`](https://registry.io/providers/spectrocloud/spectrocloud/latest/docs/data-sources/pack) data source. This value is required if the pack type is `spectro` and for `helm` if the chart is from a public helm registry. If not provided, all of `name`, `tag`, and `registry_uid` must be specified to resolve the pack UID internally.
	// +kubebuilder:validation:Optional
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`

	// (String) The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
	// The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
	// +kubebuilder:validation:Optional
	Values *string `json:"values,omitempty" tf:"values,omitempty"`
}

type ResourcesInitParameters struct {

	// (Number)
	MaxCPU *float64 `json:"maxCpu,omitempty" tf:"max_cpu,omitempty"`

	// (Number)
	MaxMemInMb *float64 `json:"maxMemInMb,omitempty" tf:"max_mem_in_mb,omitempty"`

	// (Number)
	MaxStorageInGb *float64 `json:"maxStorageInGb,omitempty" tf:"max_storage_in_gb,omitempty"`

	// (Number)
	MinCPU *float64 `json:"minCpu,omitempty" tf:"min_cpu,omitempty"`

	// (Number)
	MinMemInMb *float64 `json:"minMemInMb,omitempty" tf:"min_mem_in_mb,omitempty"`

	// (Number)
	MinStorageInGb *float64 `json:"minStorageInGb,omitempty" tf:"min_storage_in_gb,omitempty"`
}

type ResourcesObservation struct {

	// (Number)
	MaxCPU *float64 `json:"maxCpu,omitempty" tf:"max_cpu,omitempty"`

	// (Number)
	MaxMemInMb *float64 `json:"maxMemInMb,omitempty" tf:"max_mem_in_mb,omitempty"`

	// (Number)
	MaxStorageInGb *float64 `json:"maxStorageInGb,omitempty" tf:"max_storage_in_gb,omitempty"`

	// (Number)
	MinCPU *float64 `json:"minCpu,omitempty" tf:"min_cpu,omitempty"`

	// (Number)
	MinMemInMb *float64 `json:"minMemInMb,omitempty" tf:"min_mem_in_mb,omitempty"`

	// (Number)
	MinStorageInGb *float64 `json:"minStorageInGb,omitempty" tf:"min_storage_in_gb,omitempty"`
}

type ResourcesParameters struct {

	// (Number)
	// +kubebuilder:validation:Optional
	MaxCPU *float64 `json:"maxCpu,omitempty" tf:"max_cpu,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	MaxMemInMb *float64 `json:"maxMemInMb,omitempty" tf:"max_mem_in_mb,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	MaxStorageInGb *float64 `json:"maxStorageInGb,omitempty" tf:"max_storage_in_gb,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	MinCPU *float64 `json:"minCpu,omitempty" tf:"min_cpu,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	MinMemInMb *float64 `json:"minMemInMb,omitempty" tf:"min_mem_in_mb,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	MinStorageInGb *float64 `json:"minStorageInGb,omitempty" tf:"min_storage_in_gb,omitempty"`
}

type ScanPolicyInitParameters struct {

	// (String) The schedule for configuration scan.
	// The schedule for configuration scan.
	ConfigurationScanSchedule *string `json:"configurationScanSchedule,omitempty" tf:"configuration_scan_schedule,omitempty"`

	// (String) The schedule for conformance scan.
	// The schedule for conformance scan.
	ConformanceScanSchedule *string `json:"conformanceScanSchedule,omitempty" tf:"conformance_scan_schedule,omitempty"`

	// (String) The schedule for penetration scan.
	// The schedule for penetration scan.
	PenetrationScanSchedule *string `json:"penetrationScanSchedule,omitempty" tf:"penetration_scan_schedule,omitempty"`
}

type ScanPolicyObservation struct {

	// (String) The schedule for configuration scan.
	// The schedule for configuration scan.
	ConfigurationScanSchedule *string `json:"configurationScanSchedule,omitempty" tf:"configuration_scan_schedule,omitempty"`

	// (String) The schedule for conformance scan.
	// The schedule for conformance scan.
	ConformanceScanSchedule *string `json:"conformanceScanSchedule,omitempty" tf:"conformance_scan_schedule,omitempty"`

	// (String) The schedule for penetration scan.
	// The schedule for penetration scan.
	PenetrationScanSchedule *string `json:"penetrationScanSchedule,omitempty" tf:"penetration_scan_schedule,omitempty"`
}

type ScanPolicyParameters struct {

	// (String) The schedule for configuration scan.
	// The schedule for configuration scan.
	// +kubebuilder:validation:Optional
	ConfigurationScanSchedule *string `json:"configurationScanSchedule" tf:"configuration_scan_schedule,omitempty"`

	// (String) The schedule for conformance scan.
	// The schedule for conformance scan.
	// +kubebuilder:validation:Optional
	ConformanceScanSchedule *string `json:"conformanceScanSchedule" tf:"conformance_scan_schedule,omitempty"`

	// (String) The schedule for penetration scan.
	// The schedule for penetration scan.
	// +kubebuilder:validation:Optional
	PenetrationScanSchedule *string `json:"penetrationScanSchedule" tf:"penetration_scan_schedule,omitempty"`
}

type SubjectsInitParameters struct {

	// (String)
	// The name of the subject. Required if 'type' is set to 'User' or 'Group'.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	// The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SubjectsObservation struct {

	// (String)
	// The name of the subject. Required if 'type' is set to 'User' or 'Group'.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	// The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SubjectsParameters struct {

	// (String)
	// The name of the subject. Required if 'type' is set to 'User' or 'Group'.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (String) The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
	// The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (String) The type of the pack. Allowed values are spectro, manifest, helm, or oci. The default value is spectro. If using an OCI registry for pack, set the type to oci.
	// The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            ClusterParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ClusterInitParameters `json:"initProvider,omitempty"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Cluster is the Schema for the Clusters API. A resource to manage a Palette Virtual Cluster.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,palette}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ClusterSpec   `json:"spec"`
	Status ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
