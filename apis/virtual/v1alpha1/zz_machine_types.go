/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CloudInitNoCloudObservation struct {
}

type CloudInitNoCloudParameters struct {

	// The user data to use for the cloud-init no cloud disk. This can be a local file path, a remote URL, or a registry URL.
	// +kubebuilder:validation:Required
	UserData *string `json:"userData" tf:"user_data,omitempty"`
}

type ContainerDiskObservation struct {
}

type ContainerDiskParameters struct {

	// The URL of the container image to use as the disk. This can be a local file path, a remote URL, or a registry URL.
	// +kubebuilder:validation:Required
	ImageURL *string `json:"imageUrl" tf:"image_url,omitempty"`
}

type DevicesObservation struct {
}

type DevicesParameters struct {

	// +kubebuilder:validation:Required
	Disk []DiskParameters `json:"disk" tf:"disk,omitempty"`

	// +kubebuilder:validation:Required
	Interface []InterfaceParameters `json:"interface" tf:"interface,omitempty"`
}

type DiskObservation struct {
}

type DiskParameters struct {

	// The bus type of the disk. This is the name that will be used to identify the disk in the guest OS.
	// +kubebuilder:validation:Required
	Bus *string `json:"bus" tf:"bus,omitempty"`

	// The name of the disk. This is the name that will be used to identify the disk in the guest OS.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type InterfaceObservation struct {
}

type InterfaceParameters struct {

	// The name of the interface. This is the name that will be used to identify the device interface in the guest OS.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type MachineObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type MachineParameters struct {

	// The annotations of the virtual machine.
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// The name of the source virtual machine that a clone will be created of.
	// +kubebuilder:validation:Optional
	BaseVMName *string `json:"baseVmName,omitempty" tf:"base_vm_name,omitempty"`

	// The number of CPU cores to be allocated to the virtual machine. Default value is `1`.
	// +kubebuilder:validation:Optional
	CPUCores *float64 `json:"cpuCores,omitempty" tf:"cpu_cores,omitempty"`

	// The cloud-init user data to be used for the virtual machine. Default value is `#cloud-config
	// ssh_pwauth: True
	// chpasswd: { expire: False }
	// password: spectro
	// disable_root: false
	// `.
	// +kubebuilder:validation:Optional
	CloudInitUserData *string `json:"cloudInitUserData,omitempty" tf:"cloud_init_user_data,omitempty"`

	// The cluster UID to which the virtual machine belongs to.
	// +kubebuilder:validation:Required
	ClusterUID *string `json:"clusterUid" tf:"cluster_uid,omitempty"`

	// +kubebuilder:validation:Optional
	Devices []DevicesParameters `json:"devices,omitempty" tf:"devices,omitempty"`

	// The URL of the VM template image to be used for the virtual machine.
	// +kubebuilder:validation:Optional
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`

	// The labels of the virtual machine.
	// +kubebuilder:validation:Optional
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The amount of memory to be allocated to the virtual machine. Default value is `2G`.
	// +kubebuilder:validation:Optional
	Memory *string `json:"memory,omitempty" tf:"memory,omitempty"`

	// The namespace of the virtual machine.
	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkSpec []NetworkSpecParameters `json:"networkSpec,omitempty" tf:"network_spec,omitempty"`

	// If set to `true`, the virtual machine will be started when the cluster is launched. Default value is `true`.
	// +kubebuilder:validation:Optional
	RunOnLaunch *bool `json:"runOnLaunch,omitempty" tf:"run_on_launch,omitempty"`

	// The action to be performed on the virtual machine. Valid values are: `start`, `stop`, `restart`, `pause`, `resume`, `migrate`. Default value is `start`.
	// +kubebuilder:validation:Optional
	VMAction *string `json:"vmAction,omitempty" tf:"vm_action,omitempty"`

	// The state of the virtual machine.  The virtual machine can be in one of the following states: `running`, `stopped`, `paused`, `migrating`, `error`, `unknown`.
	// +kubebuilder:validation:Optional
	VMState *string `json:"vmState,omitempty" tf:"vm_state,omitempty"`

	// The volume specification for the virtual machine.
	// +kubebuilder:validation:Optional
	VolumeSpec []VolumeSpecParameters `json:"volumeSpec,omitempty" tf:"volume_spec,omitempty"`
}

type NetworkObservation struct {
}

type NetworkParameters struct {

	// The name of the network to be attached to the virtual machine.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type NetworkSpecObservation struct {
}

type NetworkSpecParameters struct {

	// The network specification for the virtual machine.
	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`
}

type VolumeObservation struct {
}

type VolumeParameters struct {

	// Used to specify a cloud-init `noCloud` image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init `noCloud `image and used as the disk for the VM
	// +kubebuilder:validation:Optional
	CloudInitNoCloud []CloudInitNoCloudParameters `json:"cloudInitNoCloud,omitempty" tf:"cloud_init_no_cloud,omitempty"`

	// A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM.
	// +kubebuilder:validation:Optional
	ContainerDisk []ContainerDiskParameters `json:"containerDisk,omitempty" tf:"container_disk,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type VolumeSpecObservation struct {
}

type VolumeSpecParameters struct {

	// +kubebuilder:validation:Optional
	Volume []VolumeParameters `json:"volume,omitempty" tf:"volume,omitempty"`
}

// MachineSpec defines the desired state of Machine
type MachineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MachineParameters `json:"forProvider"`
}

// MachineStatus defines the observed state of Machine.
type MachineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MachineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Machine is the Schema for the Machines API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,palette}
type Machine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MachineSpec   `json:"spec"`
	Status            MachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MachineList contains a list of Machines
type MachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Machine `json:"items"`
}

// Repository type metadata.
var (
	Machine_Kind             = "Machine"
	Machine_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Machine_Kind}.String()
	Machine_KindAPIVersion   = Machine_Kind + "." + CRDGroupVersion.String()
	Machine_GroupVersionKind = CRDGroupVersion.WithKind(Machine_Kind)
)

func init() {
	SchemeBuilder.Register(&Machine{}, &MachineList{})
}
