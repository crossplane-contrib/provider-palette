// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AffinityInitParameters struct {

	// (Block List, Max: 1) Node affinity scheduling rules for the pod. (see below for nested schema)
	// Node affinity scheduling rules for the pod.
	NodeAffinity []NodeAffinityInitParameters `json:"nodeAffinity,omitempty" tf:"node_affinity,omitempty"`

	// pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.) (see below for nested schema)
	// Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
	PodAffinity []PodAffinityInitParameters `json:"podAffinity,omitempty" tf:"pod_affinity,omitempty"`

	// pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.) (see below for nested schema)
	// Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
	PodAntiAffinity []PodAntiAffinityInitParameters `json:"podAntiAffinity,omitempty" tf:"pod_anti_affinity,omitempty"`
}

type AffinityObservation struct {

	// (Block List, Max: 1) Node affinity scheduling rules for the pod. (see below for nested schema)
	// Node affinity scheduling rules for the pod.
	NodeAffinity []NodeAffinityObservation `json:"nodeAffinity,omitempty" tf:"node_affinity,omitempty"`

	// pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.) (see below for nested schema)
	// Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
	PodAffinity []PodAffinityObservation `json:"podAffinity,omitempty" tf:"pod_affinity,omitempty"`

	// pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.) (see below for nested schema)
	// Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
	PodAntiAffinity []PodAntiAffinityObservation `json:"podAntiAffinity,omitempty" tf:"pod_anti_affinity,omitempty"`
}

type AffinityParameters struct {

	// (Block List, Max: 1) Node affinity scheduling rules for the pod. (see below for nested schema)
	// Node affinity scheduling rules for the pod.
	// +kubebuilder:validation:Optional
	NodeAffinity []NodeAffinityParameters `json:"nodeAffinity,omitempty" tf:"node_affinity,omitempty"`

	// pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.) (see below for nested schema)
	// Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
	// +kubebuilder:validation:Optional
	PodAffinity []PodAffinityParameters `json:"podAffinity,omitempty" tf:"pod_affinity,omitempty"`

	// pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.) (see below for nested schema)
	// Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
	// +kubebuilder:validation:Optional
	PodAntiAffinity []PodAntiAffinityParameters `json:"podAntiAffinity,omitempty" tf:"pod_anti_affinity,omitempty"`
}

type BlankInitParameters struct {
}

type BlankObservation struct {
}

type BlankParameters struct {
}

type CPUInitParameters struct {

	// (Number) Cores is the number of cores inside the vmi. Must be a value greater or equal 1
	// Cores is the number of cores inside the vmi. Must be a value greater or equal 1
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// (Number) Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.
	// Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.
	Sockets *float64 `json:"sockets,omitempty" tf:"sockets,omitempty"`

	// (Number) Threads is the number of threads inside the vmi. Must be a value greater or equal 1.
	// Threads is the number of threads inside the vmi. Must be a value greater or equal 1.
	Threads *float64 `json:"threads,omitempty" tf:"threads,omitempty"`
}

type CPUObservation struct {

	// (Number) Cores is the number of cores inside the vmi. Must be a value greater or equal 1
	// Cores is the number of cores inside the vmi. Must be a value greater or equal 1
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// (Number) Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.
	// Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.
	Sockets *float64 `json:"sockets,omitempty" tf:"sockets,omitempty"`

	// (Number) Threads is the number of threads inside the vmi. Must be a value greater or equal 1.
	// Threads is the number of threads inside the vmi. Must be a value greater or equal 1.
	Threads *float64 `json:"threads,omitempty" tf:"threads,omitempty"`
}

type CPUParameters struct {

	// (Number) Cores is the number of cores inside the vmi. Must be a value greater or equal 1
	// Cores is the number of cores inside the vmi. Must be a value greater or equal 1
	// +kubebuilder:validation:Optional
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// (Number) Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.
	// Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.
	// +kubebuilder:validation:Optional
	Sockets *float64 `json:"sockets,omitempty" tf:"sockets,omitempty"`

	// (Number) Threads is the number of threads inside the vmi. Must be a value greater or equal 1.
	// Threads is the number of threads inside the vmi. Must be a value greater or equal 1.
	// +kubebuilder:validation:Optional
	Threads *float64 `json:"threads,omitempty" tf:"threads,omitempty"`
}

type CloudInitConfigDriveInitParameters struct {

	// init networkdata.
	// NetworkData contains config drive inline cloud-init networkdata.
	NetworkData *string `json:"networkData,omitempty" tf:"network_data,omitempty"`

	// init networkdata as a base64 encoded string.
	// NetworkDataBase64 contains config drive cloud-init networkdata as a base64 encoded string.
	NetworkDataBase64 *string `json:"networkDataBase64,omitempty" tf:"network_data_base64,omitempty"`

	// (Block List, Max: 1) NetworkDataSecretRef references a k8s secret that contains config drive networkdata. (see below for nested schema)
	// NetworkDataSecretRef references a k8s secret that contains config drive networkdata.
	NetworkDataSecretRef []NetworkDataSecretRefInitParameters `json:"networkDataSecretRef,omitempty" tf:"network_data_secret_ref,omitempty"`

	// init userdata.
	// UserData contains config drive inline cloud-init userdata.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// init userdata as a base64 encoded string.
	// UserDataBase64 contains config drive cloud-init userdata as a base64 encoded string.
	UserDataBase64 *string `json:"userDataBase64,omitempty" tf:"user_data_base64,omitempty"`

	// (Block List, Max: 1) UserDataSecretRef references a k8s secret that contains config drive userdata. (see below for nested schema)
	// UserDataSecretRef references a k8s secret that contains config drive userdata.
	UserDataSecretRef []UserDataSecretRefInitParameters `json:"userDataSecretRef,omitempty" tf:"user_data_secret_ref,omitempty"`
}

type CloudInitConfigDriveObservation struct {

	// init networkdata.
	// NetworkData contains config drive inline cloud-init networkdata.
	NetworkData *string `json:"networkData,omitempty" tf:"network_data,omitempty"`

	// init networkdata as a base64 encoded string.
	// NetworkDataBase64 contains config drive cloud-init networkdata as a base64 encoded string.
	NetworkDataBase64 *string `json:"networkDataBase64,omitempty" tf:"network_data_base64,omitempty"`

	// (Block List, Max: 1) NetworkDataSecretRef references a k8s secret that contains config drive networkdata. (see below for nested schema)
	// NetworkDataSecretRef references a k8s secret that contains config drive networkdata.
	NetworkDataSecretRef []NetworkDataSecretRefObservation `json:"networkDataSecretRef,omitempty" tf:"network_data_secret_ref,omitempty"`

	// init userdata.
	// UserData contains config drive inline cloud-init userdata.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// init userdata as a base64 encoded string.
	// UserDataBase64 contains config drive cloud-init userdata as a base64 encoded string.
	UserDataBase64 *string `json:"userDataBase64,omitempty" tf:"user_data_base64,omitempty"`

	// (Block List, Max: 1) UserDataSecretRef references a k8s secret that contains config drive userdata. (see below for nested schema)
	// UserDataSecretRef references a k8s secret that contains config drive userdata.
	UserDataSecretRef []UserDataSecretRefObservation `json:"userDataSecretRef,omitempty" tf:"user_data_secret_ref,omitempty"`
}

type CloudInitConfigDriveParameters struct {

	// init networkdata.
	// NetworkData contains config drive inline cloud-init networkdata.
	// +kubebuilder:validation:Optional
	NetworkData *string `json:"networkData,omitempty" tf:"network_data,omitempty"`

	// init networkdata as a base64 encoded string.
	// NetworkDataBase64 contains config drive cloud-init networkdata as a base64 encoded string.
	// +kubebuilder:validation:Optional
	NetworkDataBase64 *string `json:"networkDataBase64,omitempty" tf:"network_data_base64,omitempty"`

	// (Block List, Max: 1) NetworkDataSecretRef references a k8s secret that contains config drive networkdata. (see below for nested schema)
	// NetworkDataSecretRef references a k8s secret that contains config drive networkdata.
	// +kubebuilder:validation:Optional
	NetworkDataSecretRef []NetworkDataSecretRefParameters `json:"networkDataSecretRef,omitempty" tf:"network_data_secret_ref,omitempty"`

	// init userdata.
	// UserData contains config drive inline cloud-init userdata.
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// init userdata as a base64 encoded string.
	// UserDataBase64 contains config drive cloud-init userdata as a base64 encoded string.
	// +kubebuilder:validation:Optional
	UserDataBase64 *string `json:"userDataBase64,omitempty" tf:"user_data_base64,omitempty"`

	// (Block List, Max: 1) UserDataSecretRef references a k8s secret that contains config drive userdata. (see below for nested schema)
	// UserDataSecretRef references a k8s secret that contains config drive userdata.
	// +kubebuilder:validation:Optional
	UserDataSecretRef []UserDataSecretRefParameters `json:"userDataSecretRef,omitempty" tf:"user_data_secret_ref,omitempty"`
}

type CloudInitNoCloudInitParameters struct {

	// init userdata.
	// The user data to use for the cloud-init no cloud disk. This can be a local file path, a remote URL, or a registry URL.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type CloudInitNoCloudObservation struct {

	// init userdata.
	// The user data to use for the cloud-init no cloud disk. This can be a local file path, a remote URL, or a registry URL.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type CloudInitNoCloudParameters struct {

	// init userdata.
	// The user data to use for the cloud-init no cloud disk. This can be a local file path, a remote URL, or a registry URL.
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData" tf:"user_data,omitempty"`
}

type ConditionsInitParameters struct {

	// (String) Condition message.
	// Condition message.
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// (String) Condition reason.
	// Condition reason.
	Reason *string `json:"reason,omitempty" tf:"reason,omitempty"`

	// (Block List, Max: 1) VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing. (see below for nested schema)
	// ConditionStatus represents the status of this VM condition, if the VM currently in the condition.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String) VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	// VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ConditionsObservation struct {

	// (String) Condition message.
	// Condition message.
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// (String) Condition reason.
	// Condition reason.
	Reason *string `json:"reason,omitempty" tf:"reason,omitempty"`

	// (Block List, Max: 1) VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing. (see below for nested schema)
	// ConditionStatus represents the status of this VM condition, if the VM currently in the condition.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String) VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	// VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ConditionsParameters struct {

	// (String) Condition message.
	// Condition message.
	// +kubebuilder:validation:Optional
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// (String) Condition reason.
	// Condition reason.
	// +kubebuilder:validation:Optional
	Reason *string `json:"reason,omitempty" tf:"reason,omitempty"`

	// (Block List, Max: 1) VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing. (see below for nested schema)
	// ConditionStatus represents the status of this VM condition, if the VM currently in the condition.
	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String) VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	// VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ConfigMapInitParameters struct {

	// (Number) Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *float64 `json:"defaultMode,omitempty" tf:"default_mode,omitempty"`

	// value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'. (see below for nested schema)
	// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items []ItemsInitParameters `json:"items,omitempty" tf:"items,omitempty"`
}

type ConfigMapObservation struct {

	// (Number) Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *float64 `json:"defaultMode,omitempty" tf:"default_mode,omitempty"`

	// value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'. (see below for nested schema)
	// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items []ItemsObservation `json:"items,omitempty" tf:"items,omitempty"`
}

type ConfigMapParameters struct {

	// (Number) Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	// +kubebuilder:validation:Optional
	DefaultMode *float64 `json:"defaultMode,omitempty" tf:"default_mode,omitempty"`

	// value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'. (see below for nested schema)
	// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	// +kubebuilder:validation:Optional
	Items []ItemsParameters `json:"items,omitempty" tf:"items,omitempty"`
}

type ContainerDiskInitParameters struct {

	// (String) The registry URL of the image to download.
	// The URL of the container image to use as the disk. This can be a local file path, a remote URL, or a registry URL.
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`
}

type ContainerDiskObservation struct {

	// (String) The registry URL of the image to download.
	// The URL of the container image to use as the disk. This can be a local file path, a remote URL, or a registry URL.
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`
}

type ContainerDiskParameters struct {

	// (String) The registry URL of the image to download.
	// The URL of the container image to use as the disk. This can be a local file path, a remote URL, or a registry URL.
	// +kubebuilder:validation:Optional
	ImageURL *string `json:"imageUrl" tf:"image_url,omitempty"`
}

type DataVolumeInitParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name represents the name of the DataVolume in the same namespace.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type DataVolumeObservation struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name represents the name of the DataVolume in the same namespace.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type DataVolumeParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name represents the name of the DataVolume in the same namespace.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type DataVolumeTemplatesInitParameters struct {

	// architecture/api-conventions.md#metadata (see below for nested schema)
	// Standard DataVolume's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata []MetadataInitParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Block List, Min: 1, Max: 1) DataVolumeSpec defines our specification for a DataVolume type (see below for nested schema)
	// DataVolumeSpec defines our specification for a DataVolume type
	Spec []SpecInitParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type DataVolumeTemplatesObservation struct {

	// architecture/api-conventions.md#metadata (see below for nested schema)
	// Standard DataVolume's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata []MetadataObservation `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Block List, Min: 1, Max: 1) DataVolumeSpec defines our specification for a DataVolume type (see below for nested schema)
	// DataVolumeSpec defines our specification for a DataVolume type
	Spec []SpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`
}

type DataVolumeTemplatesParameters struct {

	// architecture/api-conventions.md#metadata (see below for nested schema)
	// Standard DataVolume's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata" tf:"metadata,omitempty"`

	// (Block List, Min: 1, Max: 1) DataVolumeSpec defines our specification for a DataVolume type (see below for nested schema)
	// DataVolumeSpec defines our specification for a DataVolume type
	// +kubebuilder:validation:Optional
	Spec []SpecParameters `json:"spec" tf:"spec,omitempty"`
}

type DiskDeviceDiskInitParameters struct {

	// (String) Bus indicates the type of disk device to emulate.
	// Bus indicates the type of disk device to emulate.
	Bus *string `json:"bus,omitempty" tf:"bus,omitempty"`

	// (String) If specified, the virtual disk will be placed on the guests pci address with the specifed PCI address. For example: 0000:81:01.10
	// If specified, the virtual disk will be placed on the guests pci address with the specifed PCI address. For example: 0000:81:01.10
	PciAddress *string `json:"pciAddress,omitempty" tf:"pci_address,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// ReadOnly. Defaults to false.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type DiskDeviceDiskObservation struct {

	// (String) Bus indicates the type of disk device to emulate.
	// Bus indicates the type of disk device to emulate.
	Bus *string `json:"bus,omitempty" tf:"bus,omitempty"`

	// (String) If specified, the virtual disk will be placed on the guests pci address with the specifed PCI address. For example: 0000:81:01.10
	// If specified, the virtual disk will be placed on the guests pci address with the specifed PCI address. For example: 0000:81:01.10
	PciAddress *string `json:"pciAddress,omitempty" tf:"pci_address,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// ReadOnly. Defaults to false.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type DiskDeviceDiskParameters struct {

	// (String) Bus indicates the type of disk device to emulate.
	// Bus indicates the type of disk device to emulate.
	// +kubebuilder:validation:Optional
	Bus *string `json:"bus" tf:"bus,omitempty"`

	// (String) If specified, the virtual disk will be placed on the guests pci address with the specifed PCI address. For example: 0000:81:01.10
	// If specified, the virtual disk will be placed on the guests pci address with the specifed PCI address. For example: 0000:81:01.10
	// +kubebuilder:validation:Optional
	PciAddress *string `json:"pciAddress,omitempty" tf:"pci_address,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// ReadOnly. Defaults to false.
	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type DiskDeviceInitParameters struct {

	// (Block List) Disks describes disks, cdroms, floppy and luns which are connected to the vmi. (see below for nested schema)
	// Attach a volume as a disk to the vmi.
	Disk []DiskDeviceDiskInitParameters `json:"disk,omitempty" tf:"disk,omitempty"`
}

type DiskDeviceObservation struct {

	// (Block List) Disks describes disks, cdroms, floppy and luns which are connected to the vmi. (see below for nested schema)
	// Attach a volume as a disk to the vmi.
	Disk []DiskDeviceDiskObservation `json:"disk,omitempty" tf:"disk,omitempty"`
}

type DiskDeviceParameters struct {

	// (Block List) Disks describes disks, cdroms, floppy and luns which are connected to the vmi. (see below for nested schema)
	// Attach a volume as a disk to the vmi.
	// +kubebuilder:validation:Optional
	Disk []DiskDeviceDiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`
}

type DiskInitParameters struct {

	// (Block List, Min: 1) DiskDevice specifies as which device the disk should be added to the guest. (see below for nested schema)
	// DiskDevice specifies as which device the disk should be added to the guest.
	DiskDevice []DiskDeviceInitParameters `json:"diskDevice,omitempty" tf:"disk_device,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name is the device name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Serial provides the ability to specify a serial number for the disk device.
	// Serial provides the ability to specify a serial number for the disk device.
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`
}

type DiskObservation struct {

	// (Block List, Min: 1) DiskDevice specifies as which device the disk should be added to the guest. (see below for nested schema)
	// DiskDevice specifies as which device the disk should be added to the guest.
	DiskDevice []DiskDeviceObservation `json:"diskDevice,omitempty" tf:"disk_device,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name is the device name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Serial provides the ability to specify a serial number for the disk device.
	// Serial provides the ability to specify a serial number for the disk device.
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`
}

type DiskParameters struct {

	// (Block List, Min: 1) DiskDevice specifies as which device the disk should be added to the guest. (see below for nested schema)
	// DiskDevice specifies as which device the disk should be added to the guest.
	// +kubebuilder:validation:Optional
	DiskDevice []DiskDeviceParameters `json:"diskDevice" tf:"disk_device,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name is the device name
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (String) Serial provides the ability to specify a serial number for the disk device.
	// Serial provides the ability to specify a serial number for the disk device.
	// +kubebuilder:validation:Optional
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`
}

type EmptyDiskInitParameters struct {

	// (String) Capacity of the sparse disk.
	// Capacity of the sparse disk.
	Capacity *string `json:"capacity,omitempty" tf:"capacity,omitempty"`
}

type EmptyDiskObservation struct {

	// (String) Capacity of the sparse disk.
	// Capacity of the sparse disk.
	Capacity *string `json:"capacity,omitempty" tf:"capacity,omitempty"`
}

type EmptyDiskParameters struct {

	// (String) Capacity of the sparse disk.
	// Capacity of the sparse disk.
	// +kubebuilder:validation:Optional
	Capacity *string `json:"capacity" tf:"capacity,omitempty"`
}

type EphemeralInitParameters struct {

	// (Block List, Max: 1) PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. (see below for nested schema)
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	PersistentVolumeClaim []PersistentVolumeClaimInitParameters `json:"persistentVolumeClaim,omitempty" tf:"persistent_volume_claim,omitempty"`
}

type EphemeralObservation struct {

	// (Block List, Max: 1) PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. (see below for nested schema)
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	PersistentVolumeClaim []PersistentVolumeClaimObservation `json:"persistentVolumeClaim,omitempty" tf:"persistent_volume_claim,omitempty"`
}

type EphemeralParameters struct {

	// (Block List, Max: 1) PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. (see below for nested schema)
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	// +kubebuilder:validation:Optional
	PersistentVolumeClaim []PersistentVolumeClaimParameters `json:"persistentVolumeClaim,omitempty" tf:"persistent_volume_claim,omitempty"`
}

type HTTPInitParameters struct {

	// (String) Cert_config_map provides a reference to the Registry certs.
	// Cert_config_map provides a reference to the Registry certs.
	CertConfigMap *string `json:"certConfigMap,omitempty" tf:"cert_config_map,omitempty"`

	// (String) Secret_ref provides the secret reference needed to access the HTTP source.
	// Secret_ref provides the secret reference needed to access the HTTP source.
	SecretRef *string `json:"secretRef,omitempty" tf:"secret_ref,omitempty"`

	// (String) url is the URL of the http source.
	// url is the URL of the http source.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type HTTPObservation struct {

	// (String) Cert_config_map provides a reference to the Registry certs.
	// Cert_config_map provides a reference to the Registry certs.
	CertConfigMap *string `json:"certConfigMap,omitempty" tf:"cert_config_map,omitempty"`

	// (String) Secret_ref provides the secret reference needed to access the HTTP source.
	// Secret_ref provides the secret reference needed to access the HTTP source.
	SecretRef *string `json:"secretRef,omitempty" tf:"secret_ref,omitempty"`

	// (String) url is the URL of the http source.
	// url is the URL of the http source.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type HTTPParameters struct {

	// (String) Cert_config_map provides a reference to the Registry certs.
	// Cert_config_map provides a reference to the Registry certs.
	// +kubebuilder:validation:Optional
	CertConfigMap *string `json:"certConfigMap,omitempty" tf:"cert_config_map,omitempty"`

	// (String) Secret_ref provides the secret reference needed to access the HTTP source.
	// Secret_ref provides the secret reference needed to access the HTTP source.
	// +kubebuilder:validation:Optional
	SecretRef *string `json:"secretRef,omitempty" tf:"secret_ref,omitempty"`

	// (String) url is the URL of the http source.
	// url is the URL of the http source.
	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type HostDiskInitParameters struct {

	// (String) Path of the disk.
	// Path of the disk.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// (String) VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	// Type of the disk, supported values are disk, directory, socket, char, block.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type HostDiskObservation struct {

	// (String) Path of the disk.
	// Path of the disk.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// (String) VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	// Type of the disk, supported values are disk, directory, socket, char, block.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type HostDiskParameters struct {

	// (String) Path of the disk.
	// Path of the disk.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// (String) VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
	// Type of the disk, supported values are disk, directory, socket, char, block.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type InterfaceInitParameters struct {

	// (String) Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
	// Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
	InterfaceBindingMethod *string `json:"interfaceBindingMethod,omitempty" tf:"interface_binding_method,omitempty"`

	// (String) Represents the method which will be used to connect the interface to the guest.
	// Represents the method which will be used to connect the interface to the guest.
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Logical name of the interface as well as a reference to the associated networks.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InterfaceObservation struct {

	// (String) Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
	// Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
	InterfaceBindingMethod *string `json:"interfaceBindingMethod,omitempty" tf:"interface_binding_method,omitempty"`

	// (String) Represents the method which will be used to connect the interface to the guest.
	// Represents the method which will be used to connect the interface to the guest.
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Logical name of the interface as well as a reference to the associated networks.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InterfaceParameters struct {

	// (String) Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
	// Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
	// +kubebuilder:validation:Optional
	InterfaceBindingMethod *string `json:"interfaceBindingMethod" tf:"interface_binding_method,omitempty"`

	// (String) Represents the method which will be used to connect the interface to the guest.
	// Represents the method which will be used to connect the interface to the guest.
	// +kubebuilder:validation:Optional
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Logical name of the interface as well as a reference to the associated networks.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type ItemsInitParameters struct {

	// (String) The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`
}

type ItemsObservation struct {

	// (String) The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`
}

type ItemsParameters struct {

	// (String) The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`
}

type LabelSelectorInitParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []LabelSelectorMatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type LabelSelectorMatchExpressionsInitParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type LabelSelectorMatchExpressionsObservation struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type LabelSelectorMatchExpressionsParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type LabelSelectorObservation struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []LabelSelectorMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type LabelSelectorParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchExpressions []LabelSelectorMatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type LivenessProbeInitParameters struct {
}

type LivenessProbeObservation struct {
}

type LivenessProbeParameters struct {
}

type MachineInitParameters struct {

	// (Block List, Max: 1) Optional pod scheduling constraints. (see below for nested schema)
	// Optional pod scheduling constraints.
	Affinity []AffinityInitParameters `json:"affinity,omitempty" tf:"affinity,omitempty"`

	// (Map of String) An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	// An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// (String) The name of the source virtual machine that a clone will be created of.
	// The name of the source virtual machine that a clone will be created of.
	BaseVMName *string `json:"baseVmName,omitempty" tf:"base_vm_name,omitempty"`

	// (Block List, Max: 1) CPU allows to specifying the CPU topology. Valid resource keys are "cores" , "sockets" and "threads" (see below for nested schema)
	// CPU allows to specifying the CPU topology. Valid resource keys are "cores" , "sockets" and "threads"
	CPU []CPUInitParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// (String) Context of the cluster. Allowed values are project, tenant. Default value is project.
	// Context of the cluster. Allowed values are `project`, `tenant`. Default value is `project`.
	ClusterContext *string `json:"clusterContext,omitempty" tf:"cluster_context,omitempty"`

	// (String) The cluster UID to which the virtual machine belongs to.
	// The cluster UID to which the virtual machine belongs to.
	ClusterUID *string `json:"clusterUid,omitempty" tf:"cluster_uid,omitempty"`

	// (String) DNSPolicy defines how a pod's DNS will be configured.
	// DNSPolicy defines how a pod's DNS will be configured.
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	// (Block List) dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference. (see below for nested schema)
	// dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference.
	DataVolumeTemplates []DataVolumeTemplatesInitParameters `json:"dataVolumeTemplates,omitempty" tf:"data_volume_templates,omitempty"`

	// (Block List) Disks describes disks, cdroms, floppy and luns which are connected to the vmi. (see below for nested schema)
	// Disks describes disks, cdroms, floppy and luns which are connected to the vmi.
	Disk []DiskInitParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// off in case of a node drain.
	// EvictionStrategy can be set to "LiveMigrate" if the VirtualMachineInstance should be migrated instead of shut-off in case of a node drain.
	EvictionStrategy *string `json:"evictionStrategy,omitempty" tf:"eviction_strategy,omitempty"`

	// architecture/api-conventions.md#idempotency
	// Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
	GenerateName *string `json:"generateName,omitempty" tf:"generate_name,omitempty"`

	// (String) Specifies the hostname of the vmi.
	// Specifies the hostname of the vmi.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// (Block List) Interfaces describe network interfaces which are added to the vmi. (see below for nested schema)
	// Interfaces describe network interfaces which are added to the vmi.
	Interface []InterfaceInitParameters `json:"interface,omitempty" tf:"interface,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	// Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List, Max: 1) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	LivenessProbe []LivenessProbeInitParameters `json:"livenessProbe,omitempty" tf:"liveness_probe,omitempty"`

	// (Block List, Max: 1) Memory allows specifying the vmi memory features. (see below for nested schema)
	// Memory allows specifying the vmi memory features.
	Memory []MemoryInitParameters `json:"memory,omitempty" tf:"memory,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// Namespace defines the space within, Name must be unique.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Block List) List of networks that can be attached to a vm's virtual interface. (see below for nested schema)
	// List of networks that can be attached to a vm's virtual interface.
	Network []NetworkInitParameters `json:"network,omitempty" tf:"network,omitempty"`

	// (Map of String) NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node.
	// NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node.
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// (Block List, Max: 1) Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty (see below for nested schema)
	// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
	PodDNSConfig []PodDNSConfigInitParameters `json:"podDnsConfig,omitempty" tf:"pod_dns_config,omitempty"`

	// (String) If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
	// If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
	PriorityClassName *string `json:"priorityClassName,omitempty" tf:"priority_class_name,omitempty"`

	// (Block List, Max: 1) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	ReadinessProbe []ReadinessProbeInitParameters `json:"readinessProbe,omitempty" tf:"readiness_probe,omitempty"`

	// (Block List, Min: 1, Max: 1) Resources describes the Compute Resources required by this vmi. (see below for nested schema)
	// Resources describes the Compute Resources required by this vmi.
	Resources []MachineResourcesInitParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Boolean) If set to true, the virtual machine will be started when the cluster is launched. Default value is true.
	// If set to `true`, the virtual machine will be started when the cluster is launched. Default value is `true`.
	RunOnLaunch *bool `json:"runOnLaunch,omitempty" tf:"run_on_launch,omitempty"`

	// (String) Running state indicates the requested running state of the VirtualMachineInstance, mutually exclusive with Running.
	// Running state indicates the requested running state of the VirtualMachineInstance, mutually exclusive with Running.
	RunStrategy *string `json:"runStrategy,omitempty" tf:"run_strategy,omitempty"`

	// (String) If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
	// If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
	SchedulerName *string `json:"schedulerName,omitempty" tf:"scheduler_name,omitempty"`

	// (Block List, Max: 1) VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing. (see below for nested schema)
	// VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing.
	Status []StatusInitParameters `json:"status,omitempty" tf:"status,omitempty"`

	// (String) If specified, the fully qualified vmi hostname will be "...svc.".
	// If specified, the fully qualified vmi hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
	Subdomain *string `json:"subdomain,omitempty" tf:"subdomain,omitempty"`

	// (Number) Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
	// Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
	TerminationGracePeriodSeconds *float64 `json:"terminationGracePeriodSeconds,omitempty" tf:"termination_grace_period_seconds,omitempty"`

	// (Block List) If specified, the pod's toleration. Optional: Defaults to empty (see below for nested schema)
	// If specified, the pod's toleration. Optional: Defaults to empty
	Tolerations []TolerationsInitParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// (String) The action to be performed on the virtual machine. Valid values are: start, stop, restart, pause, resume, migrate. Default value is start.
	// The action to be performed on the virtual machine. Valid values are: `start`, `stop`, `restart`, `pause`, `resume`, `migrate`. Default value is `start`.
	VMAction *string `json:"vmAction,omitempty" tf:"vm_action,omitempty"`

	// (Block List) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	Volume []VolumeInitParameters `json:"volume,omitempty" tf:"volume,omitempty"`
}

type MachineObservation struct {

	// (Block List, Max: 1) Optional pod scheduling constraints. (see below for nested schema)
	// Optional pod scheduling constraints.
	Affinity []AffinityObservation `json:"affinity,omitempty" tf:"affinity,omitempty"`

	// (Map of String) An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	// An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// (String) The name of the source virtual machine that a clone will be created of.
	// The name of the source virtual machine that a clone will be created of.
	BaseVMName *string `json:"baseVmName,omitempty" tf:"base_vm_name,omitempty"`

	// (Block List, Max: 1) CPU allows to specifying the CPU topology. Valid resource keys are "cores" , "sockets" and "threads" (see below for nested schema)
	// CPU allows to specifying the CPU topology. Valid resource keys are "cores" , "sockets" and "threads"
	CPU []CPUObservation `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// (String) Context of the cluster. Allowed values are project, tenant. Default value is project.
	// Context of the cluster. Allowed values are `project`, `tenant`. Default value is `project`.
	ClusterContext *string `json:"clusterContext,omitempty" tf:"cluster_context,omitempty"`

	// (String) The cluster UID to which the virtual machine belongs to.
	// The cluster UID to which the virtual machine belongs to.
	ClusterUID *string `json:"clusterUid,omitempty" tf:"cluster_uid,omitempty"`

	// (String) DNSPolicy defines how a pod's DNS will be configured.
	// DNSPolicy defines how a pod's DNS will be configured.
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	// (Block List) dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference. (see below for nested schema)
	// dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference.
	DataVolumeTemplates []DataVolumeTemplatesObservation `json:"dataVolumeTemplates,omitempty" tf:"data_volume_templates,omitempty"`

	// (Block List) Disks describes disks, cdroms, floppy and luns which are connected to the vmi. (see below for nested schema)
	// Disks describes disks, cdroms, floppy and luns which are connected to the vmi.
	Disk []DiskObservation `json:"disk,omitempty" tf:"disk,omitempty"`

	// off in case of a node drain.
	// EvictionStrategy can be set to "LiveMigrate" if the VirtualMachineInstance should be migrated instead of shut-off in case of a node drain.
	EvictionStrategy *string `json:"evictionStrategy,omitempty" tf:"eviction_strategy,omitempty"`

	// architecture/api-conventions.md#idempotency
	// Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
	GenerateName *string `json:"generateName,omitempty" tf:"generate_name,omitempty"`

	// (Number) A sequence number representing a specific generation of the desired state.
	// A sequence number representing a specific generation of the desired state.
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`

	// (String) Specifies the hostname of the vmi.
	// Specifies the hostname of the vmi.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List) Interfaces describe network interfaces which are added to the vmi. (see below for nested schema)
	// Interfaces describe network interfaces which are added to the vmi.
	Interface []InterfaceObservation `json:"interface,omitempty" tf:"interface,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	// Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List, Max: 1) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	LivenessProbe []LivenessProbeParameters `json:"livenessProbe,omitempty" tf:"liveness_probe,omitempty"`

	// (Block List, Max: 1) Memory allows specifying the vmi memory features. (see below for nested schema)
	// Memory allows specifying the vmi memory features.
	Memory []MemoryObservation `json:"memory,omitempty" tf:"memory,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// Namespace defines the space within, Name must be unique.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Block List) List of networks that can be attached to a vm's virtual interface. (see below for nested schema)
	// List of networks that can be attached to a vm's virtual interface.
	Network []NetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	// (Map of String) NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node.
	// NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node.
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// (Block List, Max: 1) Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty (see below for nested schema)
	// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
	PodDNSConfig []PodDNSConfigObservation `json:"podDnsConfig,omitempty" tf:"pod_dns_config,omitempty"`

	// (String) If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
	// If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
	PriorityClassName *string `json:"priorityClassName,omitempty" tf:"priority_class_name,omitempty"`

	// (Block List, Max: 1) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	ReadinessProbe []ReadinessProbeParameters `json:"readinessProbe,omitempty" tf:"readiness_probe,omitempty"`

	// (String) An opaque value that represents the internal version of this VM that can be used by clients to determine when VM has changed.
	// An opaque value that represents the internal version of this VM that can be used by clients to determine when VM has changed.
	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`

	// (Block List, Min: 1, Max: 1) Resources describes the Compute Resources required by this vmi. (see below for nested schema)
	// Resources describes the Compute Resources required by this vmi.
	Resources []MachineResourcesObservation `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Boolean) If set to true, the virtual machine will be started when the cluster is launched. Default value is true.
	// If set to `true`, the virtual machine will be started when the cluster is launched. Default value is `true`.
	RunOnLaunch *bool `json:"runOnLaunch,omitempty" tf:"run_on_launch,omitempty"`

	// (String) Running state indicates the requested running state of the VirtualMachineInstance, mutually exclusive with Running.
	// Running state indicates the requested running state of the VirtualMachineInstance, mutually exclusive with Running.
	RunStrategy *string `json:"runStrategy,omitempty" tf:"run_strategy,omitempty"`

	// (String) If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
	// If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
	SchedulerName *string `json:"schedulerName,omitempty" tf:"scheduler_name,omitempty"`

	// (String) A URL representing this VM.
	// A URL representing this VM.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// (Block List, Max: 1) VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing. (see below for nested schema)
	// VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing.
	Status []StatusObservation `json:"status,omitempty" tf:"status,omitempty"`

	// (String) If specified, the fully qualified vmi hostname will be "...svc.".
	// If specified, the fully qualified vmi hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
	Subdomain *string `json:"subdomain,omitempty" tf:"subdomain,omitempty"`

	// (Number) Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
	// Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
	TerminationGracePeriodSeconds *float64 `json:"terminationGracePeriodSeconds,omitempty" tf:"termination_grace_period_seconds,omitempty"`

	// (Block List) If specified, the pod's toleration. Optional: Defaults to empty (see below for nested schema)
	// If specified, the pod's toleration. Optional: Defaults to empty
	Tolerations []TolerationsObservation `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// (String) The unique in time and space value for this VM.
	// The unique in time and space value for this VM.
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`

	// (String) The action to be performed on the virtual machine. Valid values are: start, stop, restart, pause, resume, migrate. Default value is start.
	// The action to be performed on the virtual machine. Valid values are: `start`, `stop`, `restart`, `pause`, `resume`, `migrate`. Default value is `start`.
	VMAction *string `json:"vmAction,omitempty" tf:"vm_action,omitempty"`

	// (Block List) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	Volume []VolumeObservation `json:"volume,omitempty" tf:"volume,omitempty"`
}

type MachineParameters struct {

	// (Block List, Max: 1) Optional pod scheduling constraints. (see below for nested schema)
	// Optional pod scheduling constraints.
	// +kubebuilder:validation:Optional
	Affinity []AffinityParameters `json:"affinity,omitempty" tf:"affinity,omitempty"`

	// (Map of String) An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	// An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// (String) The name of the source virtual machine that a clone will be created of.
	// The name of the source virtual machine that a clone will be created of.
	// +kubebuilder:validation:Optional
	BaseVMName *string `json:"baseVmName,omitempty" tf:"base_vm_name,omitempty"`

	// (Block List, Max: 1) CPU allows to specifying the CPU topology. Valid resource keys are "cores" , "sockets" and "threads" (see below for nested schema)
	// CPU allows to specifying the CPU topology. Valid resource keys are "cores" , "sockets" and "threads"
	// +kubebuilder:validation:Optional
	CPU []CPUParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// (String) Context of the cluster. Allowed values are project, tenant. Default value is project.
	// Context of the cluster. Allowed values are `project`, `tenant`. Default value is `project`.
	// +kubebuilder:validation:Optional
	ClusterContext *string `json:"clusterContext,omitempty" tf:"cluster_context,omitempty"`

	// (String) The cluster UID to which the virtual machine belongs to.
	// The cluster UID to which the virtual machine belongs to.
	// +kubebuilder:validation:Optional
	ClusterUID *string `json:"clusterUid,omitempty" tf:"cluster_uid,omitempty"`

	// (String) DNSPolicy defines how a pod's DNS will be configured.
	// DNSPolicy defines how a pod's DNS will be configured.
	// +kubebuilder:validation:Optional
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	// (Block List) dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference. (see below for nested schema)
	// dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference.
	// +kubebuilder:validation:Optional
	DataVolumeTemplates []DataVolumeTemplatesParameters `json:"dataVolumeTemplates,omitempty" tf:"data_volume_templates,omitempty"`

	// (Block List) Disks describes disks, cdroms, floppy and luns which are connected to the vmi. (see below for nested schema)
	// Disks describes disks, cdroms, floppy and luns which are connected to the vmi.
	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// off in case of a node drain.
	// EvictionStrategy can be set to "LiveMigrate" if the VirtualMachineInstance should be migrated instead of shut-off in case of a node drain.
	// +kubebuilder:validation:Optional
	EvictionStrategy *string `json:"evictionStrategy,omitempty" tf:"eviction_strategy,omitempty"`

	// architecture/api-conventions.md#idempotency
	// Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
	// +kubebuilder:validation:Optional
	GenerateName *string `json:"generateName,omitempty" tf:"generate_name,omitempty"`

	// (String) Specifies the hostname of the vmi.
	// Specifies the hostname of the vmi.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// (Block List) Interfaces describe network interfaces which are added to the vmi. (see below for nested schema)
	// Interfaces describe network interfaces which are added to the vmi.
	// +kubebuilder:validation:Optional
	Interface []InterfaceParameters `json:"interface,omitempty" tf:"interface,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	// Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List, Max: 1) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	// +kubebuilder:validation:Optional
	LivenessProbe []LivenessProbeParameters `json:"livenessProbe,omitempty" tf:"liveness_probe,omitempty"`

	// (Block List, Max: 1) Memory allows specifying the vmi memory features. (see below for nested schema)
	// Memory allows specifying the vmi memory features.
	// +kubebuilder:validation:Optional
	Memory []MemoryParameters `json:"memory,omitempty" tf:"memory,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// Namespace defines the space within, Name must be unique.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Block List) List of networks that can be attached to a vm's virtual interface. (see below for nested schema)
	// List of networks that can be attached to a vm's virtual interface.
	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// (Map of String) NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node.
	// NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node.
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// (Block List, Max: 1) Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty (see below for nested schema)
	// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
	// +kubebuilder:validation:Optional
	PodDNSConfig []PodDNSConfigParameters `json:"podDnsConfig,omitempty" tf:"pod_dns_config,omitempty"`

	// (String) If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
	// If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
	// +kubebuilder:validation:Optional
	PriorityClassName *string `json:"priorityClassName,omitempty" tf:"priority_class_name,omitempty"`

	// (Block List, Max: 1) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	// +kubebuilder:validation:Optional
	ReadinessProbe []ReadinessProbeParameters `json:"readinessProbe,omitempty" tf:"readiness_probe,omitempty"`

	// (Block List, Min: 1, Max: 1) Resources describes the Compute Resources required by this vmi. (see below for nested schema)
	// Resources describes the Compute Resources required by this vmi.
	// +kubebuilder:validation:Optional
	Resources []MachineResourcesParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Boolean) If set to true, the virtual machine will be started when the cluster is launched. Default value is true.
	// If set to `true`, the virtual machine will be started when the cluster is launched. Default value is `true`.
	// +kubebuilder:validation:Optional
	RunOnLaunch *bool `json:"runOnLaunch,omitempty" tf:"run_on_launch,omitempty"`

	// (String) Running state indicates the requested running state of the VirtualMachineInstance, mutually exclusive with Running.
	// Running state indicates the requested running state of the VirtualMachineInstance, mutually exclusive with Running.
	// +kubebuilder:validation:Optional
	RunStrategy *string `json:"runStrategy,omitempty" tf:"run_strategy,omitempty"`

	// (String) If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
	// If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
	// +kubebuilder:validation:Optional
	SchedulerName *string `json:"schedulerName,omitempty" tf:"scheduler_name,omitempty"`

	// (Block List, Max: 1) VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing. (see below for nested schema)
	// VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing.
	// +kubebuilder:validation:Optional
	Status []StatusParameters `json:"status,omitempty" tf:"status,omitempty"`

	// (String) If specified, the fully qualified vmi hostname will be "...svc.".
	// If specified, the fully qualified vmi hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
	// +kubebuilder:validation:Optional
	Subdomain *string `json:"subdomain,omitempty" tf:"subdomain,omitempty"`

	// (Number) Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
	// Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
	// +kubebuilder:validation:Optional
	TerminationGracePeriodSeconds *float64 `json:"terminationGracePeriodSeconds,omitempty" tf:"termination_grace_period_seconds,omitempty"`

	// (Block List) If specified, the pod's toleration. Optional: Defaults to empty (see below for nested schema)
	// If specified, the pod's toleration. Optional: Defaults to empty
	// +kubebuilder:validation:Optional
	Tolerations []TolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// (String) The action to be performed on the virtual machine. Valid values are: start, stop, restart, pause, resume, migrate. Default value is start.
	// The action to be performed on the virtual machine. Valid values are: `start`, `stop`, `restart`, `pause`, `resume`, `migrate`. Default value is `start`.
	// +kubebuilder:validation:Optional
	VMAction *string `json:"vmAction,omitempty" tf:"vm_action,omitempty"`

	// (Block List) Specification of the desired behavior of the VirtualMachineInstance on the host. (see below for nested schema)
	// Specification of the desired behavior of the VirtualMachineInstance on the host.
	// +kubebuilder:validation:Optional
	Volume []VolumeParameters `json:"volume,omitempty" tf:"volume,omitempty"`
}

type MachineResourcesInitParameters struct {

	// (Map of String) Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	// Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.
	// Don't ask the scheduler to take the guest-management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.
	OverCommitGuestOverhead *bool `json:"overCommitGuestOverhead,omitempty" tf:"over_commit_guest_overhead,omitempty"`

	// (Map of String) Requests is a description of the initial vmi resources.
	// Requests is a description of the initial vmi resources.
	Requests map[string]*string `json:"requests,omitempty" tf:"requests,omitempty"`
}

type MachineResourcesObservation struct {

	// (Map of String) Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	// Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.
	// Don't ask the scheduler to take the guest-management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.
	OverCommitGuestOverhead *bool `json:"overCommitGuestOverhead,omitempty" tf:"over_commit_guest_overhead,omitempty"`

	// (Map of String) Requests is a description of the initial vmi resources.
	// Requests is a description of the initial vmi resources.
	Requests map[string]*string `json:"requests,omitempty" tf:"requests,omitempty"`
}

type MachineResourcesParameters struct {

	// (Map of String) Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	// Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	// +kubebuilder:validation:Optional
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.
	// Don't ask the scheduler to take the guest-management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.
	// +kubebuilder:validation:Optional
	OverCommitGuestOverhead *bool `json:"overCommitGuestOverhead,omitempty" tf:"over_commit_guest_overhead,omitempty"`

	// (Map of String) Requests is a description of the initial vmi resources.
	// Requests is a description of the initial vmi resources.
	// +kubebuilder:validation:Optional
	Requests map[string]*string `json:"requests,omitempty" tf:"requests,omitempty"`
}

type MatchExpressionsInitParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MatchExpressionsObservation struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MatchExpressionsParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MemoryInitParameters struct {

	// (String) Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.
	// Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.
	Guest *string `json:"guest,omitempty" tf:"guest,omitempty"`

	// (String) Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
	// Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
	Hugepages *string `json:"hugepages,omitempty" tf:"hugepages,omitempty"`
}

type MemoryObservation struct {

	// (String) Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.
	// Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.
	Guest *string `json:"guest,omitempty" tf:"guest,omitempty"`

	// (String) Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
	// Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
	Hugepages *string `json:"hugepages,omitempty" tf:"hugepages,omitempty"`
}

type MemoryParameters struct {

	// (String) Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.
	// Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.
	// +kubebuilder:validation:Optional
	Guest *string `json:"guest,omitempty" tf:"guest,omitempty"`

	// (String) Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
	// Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
	// +kubebuilder:validation:Optional
	Hugepages *string `json:"hugepages,omitempty" tf:"hugepages,omitempty"`
}

type MetadataInitParameters struct {

	// (Map of String) An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	// An unstructured key value map stored with the DataVolume that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	// Map of string keys and values that can be used to organize and categorize (scope and select) the DataVolume. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the DataVolume, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// Namespace defines the space within which name of the DataVolume must be unique.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`
}

type MetadataObservation struct {

	// (Map of String) An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	// An unstructured key value map stored with the DataVolume that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// (Number) A sequence number representing a specific generation of the desired state.
	// A sequence number representing a specific generation of the desired state.
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	// Map of string keys and values that can be used to organize and categorize (scope and select) the DataVolume. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the DataVolume, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// Namespace defines the space within which name of the DataVolume must be unique.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (String) An opaque value that represents the internal version of this VM that can be used by clients to determine when VM has changed.
	// An opaque value that represents the internal version of this DataVolume that can be used by clients to determine when DataVolume has changed. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`

	// (String) A URL representing this VM.
	// A URL representing this DataVolume.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// (String) The unique in time and space value for this VM.
	// The unique in time and space value for this DataVolume. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type MetadataParameters struct {

	// (Map of String) An unstructured key value map stored with the VM that may be used to store arbitrary metadata.
	// An unstructured key value map stored with the DataVolume that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.
	// Map of string keys and values that can be used to organize and categorize (scope and select) the DataVolume. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the DataVolume, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// Namespace defines the space within which name of the DataVolume must be unique.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`
}

type MultusInitParameters struct {

	// cni.io/default-network annotation.
	// Select the default network and add it to the multus-cni.io/default-network annotation.
	Default *bool `json:"default,omitempty" tf:"default,omitempty"`

	// (String) References to a NetworkAttachmentDefinition CRD object. Format: , /. If namespace is not specified, VMI namespace is assumed.
	// References to a NetworkAttachmentDefinition CRD object. Format: <networkName>, <namespace>/<networkName>. If namespace is not specified, VMI namespace is assumed.
	NetworkName *string `json:"networkName,omitempty" tf:"network_name,omitempty"`
}

type MultusObservation struct {

	// cni.io/default-network annotation.
	// Select the default network and add it to the multus-cni.io/default-network annotation.
	Default *bool `json:"default,omitempty" tf:"default,omitempty"`

	// (String) References to a NetworkAttachmentDefinition CRD object. Format: , /. If namespace is not specified, VMI namespace is assumed.
	// References to a NetworkAttachmentDefinition CRD object. Format: <networkName>, <namespace>/<networkName>. If namespace is not specified, VMI namespace is assumed.
	NetworkName *string `json:"networkName,omitempty" tf:"network_name,omitempty"`
}

type MultusParameters struct {

	// cni.io/default-network annotation.
	// Select the default network and add it to the multus-cni.io/default-network annotation.
	// +kubebuilder:validation:Optional
	Default *bool `json:"default,omitempty" tf:"default,omitempty"`

	// (String) References to a NetworkAttachmentDefinition CRD object. Format: , /. If namespace is not specified, VMI namespace is assumed.
	// References to a NetworkAttachmentDefinition CRD object. Format: <networkName>, <namespace>/<networkName>. If namespace is not specified, VMI namespace is assumed.
	// +kubebuilder:validation:Optional
	NetworkName *string `json:"networkName" tf:"network_name,omitempty"`
}

type NetworkDataSecretRefInitParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the referent.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type NetworkDataSecretRefObservation struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the referent.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type NetworkDataSecretRefParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the referent.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type NetworkInitParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Network name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Max: 1) NetworkSource represents the network type and the source interface that should be connected to the virtual machine. (see below for nested schema)
	// NetworkSource represents the network type and the source interface that should be connected to the virtual machine.
	NetworkSource []NetworkSourceInitParameters `json:"networkSource,omitempty" tf:"network_source,omitempty"`
}

type NetworkObservation struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Network name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Max: 1) NetworkSource represents the network type and the source interface that should be connected to the virtual machine. (see below for nested schema)
	// NetworkSource represents the network type and the source interface that should be connected to the virtual machine.
	NetworkSource []NetworkSourceObservation `json:"networkSource,omitempty" tf:"network_source,omitempty"`
}

type NetworkParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Network name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (Block List, Max: 1) NetworkSource represents the network type and the source interface that should be connected to the virtual machine. (see below for nested schema)
	// NetworkSource represents the network type and the source interface that should be connected to the virtual machine.
	// +kubebuilder:validation:Optional
	NetworkSource []NetworkSourceParameters `json:"networkSource,omitempty" tf:"network_source,omitempty"`
}

type NetworkSourceInitParameters struct {

	// (Block List, Max: 1) Multus network. (see below for nested schema)
	// Multus network.
	Multus []MultusInitParameters `json:"multus,omitempty" tf:"multus,omitempty"`

	// (Block List, Max: 1) Pod network. (see below for nested schema)
	// Pod network.
	Pod []PodInitParameters `json:"pod,omitempty" tf:"pod,omitempty"`
}

type NetworkSourceObservation struct {

	// (Block List, Max: 1) Multus network. (see below for nested schema)
	// Multus network.
	Multus []MultusObservation `json:"multus,omitempty" tf:"multus,omitempty"`

	// (Block List, Max: 1) Pod network. (see below for nested schema)
	// Pod network.
	Pod []PodObservation `json:"pod,omitempty" tf:"pod,omitempty"`
}

type NetworkSourceParameters struct {

	// (Block List, Max: 1) Multus network. (see below for nested schema)
	// Multus network.
	// +kubebuilder:validation:Optional
	Multus []MultusParameters `json:"multus,omitempty" tf:"multus,omitempty"`

	// (Block List, Max: 1) Pod network. (see below for nested schema)
	// Pod network.
	// +kubebuilder:validation:Optional
	Pod []PodParameters `json:"pod,omitempty" tf:"pod,omitempty"`
}

type NodeAffinityInitParameters struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []PreferredDuringSchedulingIgnoredDuringExecutionInitParameters `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution []RequiredDuringSchedulingIgnoredDuringExecutionInitParameters `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type NodeAffinityObservation struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []PreferredDuringSchedulingIgnoredDuringExecutionObservation `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution []RequiredDuringSchedulingIgnoredDuringExecutionObservation `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type NodeAffinityParameters struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	// +kubebuilder:validation:Optional
	PreferredDuringSchedulingIgnoredDuringExecution []PreferredDuringSchedulingIgnoredDuringExecutionParameters `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
	// +kubebuilder:validation:Optional
	RequiredDuringSchedulingIgnoredDuringExecution []RequiredDuringSchedulingIgnoredDuringExecutionParameters `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type NodeSelectorTermInitParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// List of node selector requirements. The requirements are ANDed.
	MatchExpressions []NodeSelectorTermMatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`
}

type NodeSelectorTermMatchExpressionsInitParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type NodeSelectorTermMatchExpressionsObservation struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type NodeSelectorTermMatchExpressionsParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type NodeSelectorTermObservation struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// List of node selector requirements. The requirements are ANDed.
	MatchExpressions []NodeSelectorTermMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`
}

type NodeSelectorTermParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// List of node selector requirements. The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchExpressions []NodeSelectorTermMatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`
}

type OptionInitParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the option.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Value of the option. Optional: Defaults to empty.
	// Value of the option. Optional: Defaults to empty.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OptionObservation struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the option.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Value of the option. Optional: Defaults to empty.
	// Value of the option. Optional: Defaults to empty.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OptionParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the option.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (String) Value of the option. Optional: Defaults to empty.
	// Value of the option. Optional: Defaults to empty.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PersistentVolumeClaimInitParameters struct {

	// volumes#persistentvolumeclaims
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName *string `json:"claimName,omitempty" tf:"claim_name,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type PersistentVolumeClaimObservation struct {

	// volumes#persistentvolumeclaims
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName *string `json:"claimName,omitempty" tf:"claim_name,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type PersistentVolumeClaimParameters struct {

	// volumes#persistentvolumeclaims
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +kubebuilder:validation:Optional
	ClaimName *string `json:"claimName" tf:"claim_name,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type PodAffinityInitParameters struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []PodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInitParameters `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInitParameters `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type PodAffinityObservation struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []PodAffinityPreferredDuringSchedulingIgnoredDuringExecutionObservation `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityRequiredDuringSchedulingIgnoredDuringExecutionObservation `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type PodAffinityParameters struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	// +kubebuilder:validation:Optional
	PreferredDuringSchedulingIgnoredDuringExecution []PodAffinityPreferredDuringSchedulingIgnoredDuringExecutionParameters `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
	// +kubebuilder:validation:Optional
	RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityRequiredDuringSchedulingIgnoredDuringExecutionParameters `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type PodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInitParameters struct {

	// (Block List, Min: 1, Max: 1) A pod affinity term, associated with the corresponding weight (see below for nested schema)
	// A pod affinity term, associated with the corresponding weight
	PodAffinityTerm []PodAffinityTermInitParameters `json:"podAffinityTerm,omitempty" tf:"pod_affinity_term,omitempty"`

	// 100
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PodAffinityPreferredDuringSchedulingIgnoredDuringExecutionObservation struct {

	// (Block List, Min: 1, Max: 1) A pod affinity term, associated with the corresponding weight (see below for nested schema)
	// A pod affinity term, associated with the corresponding weight
	PodAffinityTerm []PodAffinityTermObservation `json:"podAffinityTerm,omitempty" tf:"pod_affinity_term,omitempty"`

	// 100
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PodAffinityPreferredDuringSchedulingIgnoredDuringExecutionParameters struct {

	// (Block List, Min: 1, Max: 1) A pod affinity term, associated with the corresponding weight (see below for nested schema)
	// A pod affinity term, associated with the corresponding weight
	// +kubebuilder:validation:Optional
	PodAffinityTerm []PodAffinityTermParameters `json:"podAffinityTerm" tf:"pod_affinity_term,omitempty"`

	// 100
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type PodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInitParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInitParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAffinityRequiredDuringSchedulingIgnoredDuringExecutionObservation struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorObservation `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAffinityRequiredDuringSchedulingIgnoredDuringExecutionParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	// +kubebuilder:validation:Optional
	LabelSelector []RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// +kubebuilder:validation:Optional
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	// +kubebuilder:validation:Optional
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAffinityTermInitParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []LabelSelectorInitParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAffinityTermLabelSelectorInitParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []PodAffinityTermLabelSelectorMatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type PodAffinityTermLabelSelectorMatchExpressionsInitParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type PodAffinityTermLabelSelectorMatchExpressionsObservation struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type PodAffinityTermLabelSelectorMatchExpressionsParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type PodAffinityTermLabelSelectorObservation struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []PodAffinityTermLabelSelectorMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type PodAffinityTermLabelSelectorParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchExpressions []PodAffinityTermLabelSelectorMatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type PodAffinityTermObservation struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []LabelSelectorObservation `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAffinityTermParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	// +kubebuilder:validation:Optional
	LabelSelector []LabelSelectorParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// +kubebuilder:validation:Optional
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	// +kubebuilder:validation:Optional
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAntiAffinityInitParameters struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []PodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInitParameters `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInitParameters `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type PodAntiAffinityObservation struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []PodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionObservation `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionObservation `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type PodAntiAffinityParameters struct {

	// (Block List) The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred. (see below for nested schema)
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
	// +kubebuilder:validation:Optional
	PreferredDuringSchedulingIgnoredDuringExecution []PodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionParameters `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"preferred_during_scheduling_ignored_during_execution,omitempty"`

	// (Block List, Max: 1) If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node. (see below for nested schema)
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
	// +kubebuilder:validation:Optional
	RequiredDuringSchedulingIgnoredDuringExecution []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionParameters `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" tf:"required_during_scheduling_ignored_during_execution,omitempty"`
}

type PodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInitParameters struct {

	// (Block List, Min: 1, Max: 1) A pod affinity term, associated with the corresponding weight (see below for nested schema)
	// A pod affinity term, associated with the corresponding weight
	PodAffinityTerm []PreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInitParameters `json:"podAffinityTerm,omitempty" tf:"pod_affinity_term,omitempty"`

	// 100
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionObservation struct {

	// (Block List, Min: 1, Max: 1) A pod affinity term, associated with the corresponding weight (see below for nested schema)
	// A pod affinity term, associated with the corresponding weight
	PodAffinityTerm []PreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermObservation `json:"podAffinityTerm,omitempty" tf:"pod_affinity_term,omitempty"`

	// 100
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionParameters struct {

	// (Block List, Min: 1, Max: 1) A pod affinity term, associated with the corresponding weight (see below for nested schema)
	// A pod affinity term, associated with the corresponding weight
	// +kubebuilder:validation:Optional
	PodAffinityTerm []PreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermParameters `json:"podAffinityTerm" tf:"pod_affinity_term,omitempty"`

	// 100
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInitParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInitParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInitParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInitParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsObservation struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorObservation struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchExpressions []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionObservation struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorObservation `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	// +kubebuilder:validation:Optional
	LabelSelector []PodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// +kubebuilder:validation:Optional
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	// +kubebuilder:validation:Optional
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PodDNSConfigInitParameters struct {

	// (List of String) A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
	// A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
	Nameservers []*string `json:"nameservers,omitempty" tf:"nameservers,omitempty"`

	// (Block List) A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy. (see below for nested schema)
	// A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
	Option []OptionInitParameters `json:"option,omitempty" tf:"option,omitempty"`

	// name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
	// A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
	Searches []*string `json:"searches,omitempty" tf:"searches,omitempty"`
}

type PodDNSConfigObservation struct {

	// (List of String) A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
	// A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
	Nameservers []*string `json:"nameservers,omitempty" tf:"nameservers,omitempty"`

	// (Block List) A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy. (see below for nested schema)
	// A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
	Option []OptionObservation `json:"option,omitempty" tf:"option,omitempty"`

	// name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
	// A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
	Searches []*string `json:"searches,omitempty" tf:"searches,omitempty"`
}

type PodDNSConfigParameters struct {

	// (List of String) A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
	// A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
	// +kubebuilder:validation:Optional
	Nameservers []*string `json:"nameservers,omitempty" tf:"nameservers,omitempty"`

	// (Block List) A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy. (see below for nested schema)
	// A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
	// +kubebuilder:validation:Optional
	Option []OptionParameters `json:"option,omitempty" tf:"option,omitempty"`

	// name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
	// A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
	// +kubebuilder:validation:Optional
	Searches []*string `json:"searches,omitempty" tf:"searches,omitempty"`
}

type PodInitParameters struct {

	// (String) CIDR for vm network.
	// CIDR for vm network.
	VMNetworkCidr *string `json:"vmNetworkCidr,omitempty" tf:"vm_network_cidr,omitempty"`
}

type PodObservation struct {

	// (String) CIDR for vm network.
	// CIDR for vm network.
	VMNetworkCidr *string `json:"vmNetworkCidr,omitempty" tf:"vm_network_cidr,omitempty"`
}

type PodParameters struct {

	// (String) CIDR for vm network.
	// CIDR for vm network.
	// +kubebuilder:validation:Optional
	VMNetworkCidr *string `json:"vmNetworkCidr,omitempty" tf:"vm_network_cidr,omitempty"`
}

type PreferenceInitParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// List of node selector requirements. The requirements are ANDed.
	MatchExpressions []MatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`
}

type PreferenceObservation struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// List of node selector requirements. The requirements are ANDed.
	MatchExpressions []MatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`
}

type PreferenceParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// List of node selector requirements. The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchExpressions []MatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`
}

type PreferredDuringSchedulingIgnoredDuringExecutionInitParameters struct {

	// (Block List, Min: 1, Max: 1) A node selector term, associated with the corresponding weight. (see below for nested schema)
	// A node selector term, associated with the corresponding weight.
	Preference []PreferenceInitParameters `json:"preference,omitempty" tf:"preference,omitempty"`

	// 100
	// weight is in the range 1-100
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PreferredDuringSchedulingIgnoredDuringExecutionObservation struct {

	// (Block List, Min: 1, Max: 1) A node selector term, associated with the corresponding weight. (see below for nested schema)
	// A node selector term, associated with the corresponding weight.
	Preference []PreferenceObservation `json:"preference,omitempty" tf:"preference,omitempty"`

	// 100
	// weight is in the range 1-100
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PreferredDuringSchedulingIgnoredDuringExecutionParameters struct {

	// (Block List, Min: 1, Max: 1) A node selector term, associated with the corresponding weight. (see below for nested schema)
	// A node selector term, associated with the corresponding weight.
	// +kubebuilder:validation:Optional
	Preference []PreferenceParameters `json:"preference" tf:"preference,omitempty"`

	// 100
	// weight is in the range 1-100
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type PreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInitParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []PodAffinityTermLabelSelectorInitParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermObservation struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	LabelSelector []PodAffinityTermLabelSelectorObservation `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermParameters struct {

	// (Block List) A label query over a set of resources, in this case pods. (see below for nested schema)
	// A label query over a set of resources, in this case pods.
	// +kubebuilder:validation:Optional
	LabelSelector []PodAffinityTermLabelSelectorParameters `json:"labelSelector,omitempty" tf:"label_selector,omitempty"`

	// (Set of String) namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
	// +kubebuilder:validation:Optional
	Namespaces []*string `json:"namespaces,omitempty" tf:"namespaces,omitempty"`

	// (String) empty topology key is interpreted by the scheduler as 'all topologies'
	// empty topology key is interpreted by the scheduler as 'all topologies'
	// +kubebuilder:validation:Optional
	TopologyKey *string `json:"topologyKey,omitempty" tf:"topology_key,omitempty"`
}

type PvcInitParameters struct {

	// guide/persistent-volumes#access-modes-1
	// A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
	AccessModes []*string `json:"accessModes,omitempty" tf:"access_modes,omitempty"`

	// (Block List, Min: 1, Max: 1) Resources describes the Compute Resources required by this vmi. (see below for nested schema)
	// A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
	Resources []PvcResourcesInitParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Block List, Max: 1) A label query over volumes to consider for binding. (see below for nested schema)
	// A label query over volumes to consider for binding.
	Selector []SelectorInitParameters `json:"selector,omitempty" tf:"selector,omitempty"`

	// (String) Name of the storage class requested by the claim
	// Name of the storage class requested by the claim
	StorageClassName *string `json:"storageClassName,omitempty" tf:"storage_class_name,omitempty"`

	// (String) volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
	// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
	VolumeMode *string `json:"volumeMode,omitempty" tf:"volume_mode,omitempty"`

	// (String) The binding reference to the PersistentVolume backing this claim.
	// The binding reference to the PersistentVolume backing this claim.
	VolumeName *string `json:"volumeName,omitempty" tf:"volume_name,omitempty"`
}

type PvcObservation struct {

	// guide/persistent-volumes#access-modes-1
	// A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
	AccessModes []*string `json:"accessModes,omitempty" tf:"access_modes,omitempty"`

	// (Block List, Min: 1, Max: 1) Resources describes the Compute Resources required by this vmi. (see below for nested schema)
	// A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
	Resources []PvcResourcesObservation `json:"resources,omitempty" tf:"resources,omitempty"`

	// (Block List, Max: 1) A label query over volumes to consider for binding. (see below for nested schema)
	// A label query over volumes to consider for binding.
	Selector []SelectorObservation `json:"selector,omitempty" tf:"selector,omitempty"`

	// (String) Name of the storage class requested by the claim
	// Name of the storage class requested by the claim
	StorageClassName *string `json:"storageClassName,omitempty" tf:"storage_class_name,omitempty"`

	// (String) volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
	// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
	VolumeMode *string `json:"volumeMode,omitempty" tf:"volume_mode,omitempty"`

	// (String) The binding reference to the PersistentVolume backing this claim.
	// The binding reference to the PersistentVolume backing this claim.
	VolumeName *string `json:"volumeName,omitempty" tf:"volume_name,omitempty"`
}

type PvcParameters struct {

	// guide/persistent-volumes#access-modes-1
	// A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
	// +kubebuilder:validation:Optional
	AccessModes []*string `json:"accessModes" tf:"access_modes,omitempty"`

	// (Block List, Min: 1, Max: 1) Resources describes the Compute Resources required by this vmi. (see below for nested schema)
	// A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
	// +kubebuilder:validation:Optional
	Resources []PvcResourcesParameters `json:"resources" tf:"resources,omitempty"`

	// (Block List, Max: 1) A label query over volumes to consider for binding. (see below for nested schema)
	// A label query over volumes to consider for binding.
	// +kubebuilder:validation:Optional
	Selector []SelectorParameters `json:"selector,omitempty" tf:"selector,omitempty"`

	// (String) Name of the storage class requested by the claim
	// Name of the storage class requested by the claim
	// +kubebuilder:validation:Optional
	StorageClassName *string `json:"storageClassName,omitempty" tf:"storage_class_name,omitempty"`

	// (String) volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
	// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
	// +kubebuilder:validation:Optional
	VolumeMode *string `json:"volumeMode,omitempty" tf:"volume_mode,omitempty"`

	// (String) The binding reference to the PersistentVolume backing this claim.
	// The binding reference to the PersistentVolume backing this claim.
	// +kubebuilder:validation:Optional
	VolumeName *string `json:"volumeName,omitempty" tf:"volume_name,omitempty"`
}

type PvcResourcesInitParameters struct {

	// (Map of String) Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	// Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// (Map of String) Requests is a description of the initial vmi resources.
	// Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
	Requests map[string]*string `json:"requests,omitempty" tf:"requests,omitempty"`
}

type PvcResourcesObservation struct {

	// (Map of String) Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	// Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// (Map of String) Requests is a description of the initial vmi resources.
	// Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
	Requests map[string]*string `json:"requests,omitempty" tf:"requests,omitempty"`
}

type PvcResourcesParameters struct {

	// (Map of String) Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
	// Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
	// +kubebuilder:validation:Optional
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// (Map of String) Requests is a description of the initial vmi resources.
	// Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
	// +kubebuilder:validation:Optional
	Requests map[string]*string `json:"requests,omitempty" tf:"requests,omitempty"`
}

type ReadinessProbeInitParameters struct {
}

type ReadinessProbeObservation struct {
}

type ReadinessProbeParameters struct {
}

type RegistryInitParameters struct {

	// (String) The registry URL of the image to download.
	// The registry URL of the image to download.
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`
}

type RegistryObservation struct {

	// (String) The registry URL of the image to download.
	// The registry URL of the image to download.
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`
}

type RegistryParameters struct {

	// (String) The registry URL of the image to download.
	// The registry URL of the image to download.
	// +kubebuilder:validation:Optional
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionInitParameters struct {

	// (Block List) List of node selector terms. The terms are ORed. (see below for nested schema)
	// List of node selector terms. The terms are ORed.
	NodeSelectorTerm []NodeSelectorTermInitParameters `json:"nodeSelectorTerm,omitempty" tf:"node_selector_term,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInitParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInitParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsObservation struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorObservation struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchExpressions []RequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionObservation struct {

	// (Block List) List of node selector terms. The terms are ORed. (see below for nested schema)
	// List of node selector terms. The terms are ORed.
	NodeSelectorTerm []NodeSelectorTermObservation `json:"nodeSelectorTerm,omitempty" tf:"node_selector_term,omitempty"`
}

type RequiredDuringSchedulingIgnoredDuringExecutionParameters struct {

	// (Block List) List of node selector terms. The terms are ORed. (see below for nested schema)
	// List of node selector terms. The terms are ORed.
	// +kubebuilder:validation:Optional
	NodeSelectorTerm []NodeSelectorTermParameters `json:"nodeSelectorTerm,omitempty" tf:"node_selector_term,omitempty"`
}

type SelectorInitParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []SelectorMatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type SelectorMatchExpressionsInitParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type SelectorMatchExpressionsObservation struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type SelectorMatchExpressionsParameters struct {

	// (String) The label key that the selector applies to.
	// The label key that the selector applies to.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	// An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type SelectorObservation struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	MatchExpressions []SelectorMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type SelectorParameters struct {

	// (Block List) List of node selector requirements. The requirements are ANDed. (see below for nested schema)
	// A list of label selector requirements. The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchExpressions []SelectorMatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// (Map of String) A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	// +kubebuilder:validation:Optional
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type ServiceAccountInitParameters struct {

	// (String) Name of the service account in the pod's namespace to use.
	// Name of the service account in the pod's namespace to use.
	ServiceAccountName *string `json:"serviceAccountName,omitempty" tf:"service_account_name,omitempty"`
}

type ServiceAccountObservation struct {

	// (String) Name of the service account in the pod's namespace to use.
	// Name of the service account in the pod's namespace to use.
	ServiceAccountName *string `json:"serviceAccountName,omitempty" tf:"service_account_name,omitempty"`
}

type ServiceAccountParameters struct {

	// (String) Name of the service account in the pod's namespace to use.
	// Name of the service account in the pod's namespace to use.
	// +kubebuilder:validation:Optional
	ServiceAccountName *string `json:"serviceAccountName" tf:"service_account_name,omitempty"`
}

type SourceInitParameters struct {

	// (Block List, Max: 1) DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source. (see below for nested schema)
	// DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source.
	Blank []BlankInitParameters `json:"blank,omitempty" tf:"blank,omitempty"`

	// (Block List, Max: 1) DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source. (see below for nested schema)
	// DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source.
	HTTP []HTTPInitParameters `json:"http,omitempty" tf:"http,omitempty"`

	// (Block List, Min: 1, Max: 1) PVC is a pointer to the PVC Spec we want to use. (see below for nested schema)
	// DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC.
	Pvc []SourcePvcInitParameters `json:"pvc,omitempty" tf:"pvc,omitempty"`

	// (Block List, Max: 1) DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC. (see below for nested schema)
	// DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC.
	Registry []RegistryInitParameters `json:"registry,omitempty" tf:"registry,omitempty"`
}

type SourceObservation struct {

	// (Block List, Max: 1) DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source. (see below for nested schema)
	// DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source.
	Blank []BlankParameters `json:"blank,omitempty" tf:"blank,omitempty"`

	// (Block List, Max: 1) DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source. (see below for nested schema)
	// DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source.
	HTTP []HTTPObservation `json:"http,omitempty" tf:"http,omitempty"`

	// (Block List, Min: 1, Max: 1) PVC is a pointer to the PVC Spec we want to use. (see below for nested schema)
	// DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC.
	Pvc []SourcePvcObservation `json:"pvc,omitempty" tf:"pvc,omitempty"`

	// (Block List, Max: 1) DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC. (see below for nested schema)
	// DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC.
	Registry []RegistryObservation `json:"registry,omitempty" tf:"registry,omitempty"`
}

type SourceParameters struct {

	// (Block List, Max: 1) DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source. (see below for nested schema)
	// DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source.
	// +kubebuilder:validation:Optional
	Blank []BlankParameters `json:"blank,omitempty" tf:"blank,omitempty"`

	// (Block List, Max: 1) DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source. (see below for nested schema)
	// DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source.
	// +kubebuilder:validation:Optional
	HTTP []HTTPParameters `json:"http,omitempty" tf:"http,omitempty"`

	// (Block List, Min: 1, Max: 1) PVC is a pointer to the PVC Spec we want to use. (see below for nested schema)
	// DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC.
	// +kubebuilder:validation:Optional
	Pvc []SourcePvcParameters `json:"pvc,omitempty" tf:"pvc,omitempty"`

	// (Block List, Max: 1) DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC. (see below for nested schema)
	// DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC.
	// +kubebuilder:validation:Optional
	Registry []RegistryParameters `json:"registry,omitempty" tf:"registry,omitempty"`
}

type SourcePvcInitParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// The name of the PVC.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// The namespace which the PVC located in.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`
}

type SourcePvcObservation struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// The name of the PVC.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// The namespace which the PVC located in.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`
}

type SourcePvcParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// The name of the PVC.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Namespace defines the space within, Name must be unique.
	// The namespace which the PVC located in.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`
}

type SpecInitParameters struct {

	// (String) ContentType options: "kubevirt", "archive".
	// ContentType options: "kubevirt", "archive".
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// (Block List, Min: 1, Max: 1) PVC is a pointer to the PVC Spec we want to use. (see below for nested schema)
	// PVC is a pointer to the PVC Spec we want to use.
	Pvc []PvcInitParameters `json:"pvc,omitempty" tf:"pvc,omitempty"`

	// (Block List, Max: 1) Source is the src of the data for the requested DataVolume. (see below for nested schema)
	// Source is the src of the data for the requested DataVolume.
	Source []SourceInitParameters `json:"source,omitempty" tf:"source,omitempty"`
}

type SpecObservation struct {

	// (String) ContentType options: "kubevirt", "archive".
	// ContentType options: "kubevirt", "archive".
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// (Block List, Min: 1, Max: 1) PVC is a pointer to the PVC Spec we want to use. (see below for nested schema)
	// PVC is a pointer to the PVC Spec we want to use.
	Pvc []PvcObservation `json:"pvc,omitempty" tf:"pvc,omitempty"`

	// (Block List, Max: 1) Source is the src of the data for the requested DataVolume. (see below for nested schema)
	// Source is the src of the data for the requested DataVolume.
	Source []SourceObservation `json:"source,omitempty" tf:"source,omitempty"`
}

type SpecParameters struct {

	// (String) ContentType options: "kubevirt", "archive".
	// ContentType options: "kubevirt", "archive".
	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// (Block List, Min: 1, Max: 1) PVC is a pointer to the PVC Spec we want to use. (see below for nested schema)
	// PVC is a pointer to the PVC Spec we want to use.
	// +kubebuilder:validation:Optional
	Pvc []PvcParameters `json:"pvc" tf:"pvc,omitempty"`

	// (Block List, Max: 1) Source is the src of the data for the requested DataVolume. (see below for nested schema)
	// Source is the src of the data for the requested DataVolume.
	// +kubebuilder:validation:Optional
	Source []SourceParameters `json:"source,omitempty" tf:"source,omitempty"`
}

type StateChangeRequestsInitParameters struct {

	// (String) Indicates the type of action that is requested. e.g. Start or Stop.
	// Indicates the type of action that is requested. e.g. Start or Stop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Map of String) Provides additional data in order to perform the Action.
	// Provides additional data in order to perform the Action.
	Data map[string]*string `json:"data,omitempty" tf:"data,omitempty"`

	// (String) The unique in time and space value for this VM.
	// Indicates the UUID of an existing Virtual Machine Instance that this change request applies to -- if applicable.
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type StateChangeRequestsObservation struct {

	// (String) Indicates the type of action that is requested. e.g. Start or Stop.
	// Indicates the type of action that is requested. e.g. Start or Stop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Map of String) Provides additional data in order to perform the Action.
	// Provides additional data in order to perform the Action.
	Data map[string]*string `json:"data,omitempty" tf:"data,omitempty"`

	// (String) The unique in time and space value for this VM.
	// Indicates the UUID of an existing Virtual Machine Instance that this change request applies to -- if applicable.
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type StateChangeRequestsParameters struct {

	// (String) Indicates the type of action that is requested. e.g. Start or Stop.
	// Indicates the type of action that is requested. e.g. Start or Stop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Map of String) Provides additional data in order to perform the Action.
	// Provides additional data in order to perform the Action.
	// +kubebuilder:validation:Optional
	Data map[string]*string `json:"data,omitempty" tf:"data,omitempty"`

	// (String) The unique in time and space value for this VM.
	// Indicates the UUID of an existing Virtual Machine Instance that this change request applies to -- if applicable.
	// +kubebuilder:validation:Optional
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type StatusInitParameters struct {

	// (Block List, Min: 1) Hold the state information of the VirtualMachine and its VirtualMachineInstance. (see below for nested schema)
	// Hold the state information of the VirtualMachine and its VirtualMachineInstance.
	Conditions []ConditionsInitParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (Boolean) Created indicates if the virtual machine is created in the cluster.
	// Created indicates if the virtual machine is created in the cluster.
	Created *bool `json:"created,omitempty" tf:"created,omitempty"`

	// (Boolean) Ready indicates if the virtual machine is running and ready.
	// Ready indicates if the virtual machine is running and ready.
	Ready *bool `json:"ready,omitempty" tf:"ready,omitempty"`

	// (Block List, Min: 1) StateChangeRequests indicates a list of actions that should be taken on a VMI. (see below for nested schema)
	// StateChangeRequests indicates a list of actions that should be taken on a VMI.
	StateChangeRequests []StateChangeRequestsInitParameters `json:"stateChangeRequests,omitempty" tf:"state_change_requests,omitempty"`
}

type StatusObservation struct {

	// (Block List, Min: 1) Hold the state information of the VirtualMachine and its VirtualMachineInstance. (see below for nested schema)
	// Hold the state information of the VirtualMachine and its VirtualMachineInstance.
	Conditions []ConditionsObservation `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (Boolean) Created indicates if the virtual machine is created in the cluster.
	// Created indicates if the virtual machine is created in the cluster.
	Created *bool `json:"created,omitempty" tf:"created,omitempty"`

	// (Boolean) Ready indicates if the virtual machine is running and ready.
	// Ready indicates if the virtual machine is running and ready.
	Ready *bool `json:"ready,omitempty" tf:"ready,omitempty"`

	// (Block List, Min: 1) StateChangeRequests indicates a list of actions that should be taken on a VMI. (see below for nested schema)
	// StateChangeRequests indicates a list of actions that should be taken on a VMI.
	StateChangeRequests []StateChangeRequestsObservation `json:"stateChangeRequests,omitempty" tf:"state_change_requests,omitempty"`
}

type StatusParameters struct {

	// (Block List, Min: 1) Hold the state information of the VirtualMachine and its VirtualMachineInstance. (see below for nested schema)
	// Hold the state information of the VirtualMachine and its VirtualMachineInstance.
	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions" tf:"conditions,omitempty"`

	// (Boolean) Created indicates if the virtual machine is created in the cluster.
	// Created indicates if the virtual machine is created in the cluster.
	// +kubebuilder:validation:Optional
	Created *bool `json:"created,omitempty" tf:"created,omitempty"`

	// (Boolean) Ready indicates if the virtual machine is running and ready.
	// Ready indicates if the virtual machine is running and ready.
	// +kubebuilder:validation:Optional
	Ready *bool `json:"ready,omitempty" tf:"ready,omitempty"`

	// (Block List, Min: 1) StateChangeRequests indicates a list of actions that should be taken on a VMI. (see below for nested schema)
	// StateChangeRequests indicates a list of actions that should be taken on a VMI.
	// +kubebuilder:validation:Optional
	StateChangeRequests []StateChangeRequestsParameters `json:"stateChangeRequests" tf:"state_change_requests,omitempty"`
}

type TolerationsInitParameters struct {

	// (String) Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) The label key that the selector applies to.
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *string `json:"tolerationSeconds,omitempty" tf:"toleration_seconds,omitempty"`

	// (String) Value of the option. Optional: Defaults to empty.
	// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TolerationsObservation struct {

	// (String) Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) The label key that the selector applies to.
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *string `json:"tolerationSeconds,omitempty" tf:"toleration_seconds,omitempty"`

	// (String) Value of the option. Optional: Defaults to empty.
	// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TolerationsParameters struct {

	// (String) Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) The label key that the selector applies to.
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	// +kubebuilder:validation:Optional
	TolerationSeconds *string `json:"tolerationSeconds,omitempty" tf:"toleration_seconds,omitempty"`

	// (String) Value of the option. Optional: Defaults to empty.
	// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type UserDataSecretRefInitParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the referent.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type UserDataSecretRefObservation struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the referent.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type UserDataSecretRefParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Name of the referent.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type VolumeInitParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Volume's name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified. (see below for nested schema)
	// VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified.
	VolumeSource []VolumeSourceInitParameters `json:"volumeSource,omitempty" tf:"volume_source,omitempty"`
}

type VolumeObservation struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Volume's name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified. (see below for nested schema)
	// VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified.
	VolumeSource []VolumeSourceObservation `json:"volumeSource,omitempty" tf:"volume_source,omitempty"`
}

type VolumeParameters struct {

	// (String) Name of the virtual machine, must be unique. Cannot be updated.
	// Volume's name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified. (see below for nested schema)
	// VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified.
	// +kubebuilder:validation:Optional
	VolumeSource []VolumeSourceParameters `json:"volumeSource" tf:"volume_source,omitempty"`
}

type VolumeSourceInitParameters struct {

	// init Config Drive user-data source. (see below for nested schema)
	// CloudInitConfigDrive represents a cloud-init Config Drive user-data source.
	CloudInitConfigDrive []CloudInitConfigDriveInitParameters `json:"cloudInitConfigDrive,omitempty" tf:"cloud_init_config_drive,omitempty"`

	// init noCloud image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init noCloud image and used as the disk for the VM (see below for nested schema)
	// Used to specify a cloud-init `noCloud` image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init `noCloud `image and used as the disk for the VM
	CloudInitNoCloud []CloudInitNoCloudInitParameters `json:"cloudInitNoCloud,omitempty" tf:"cloud_init_no_cloud,omitempty"`

	// (Block List, Max: 1) ConfigMapVolumeSource adapts a ConfigMap into a volume. (see below for nested schema)
	// ConfigMapVolumeSource adapts a ConfigMap into a volume.
	ConfigMap []ConfigMapInitParameters `json:"configMap,omitempty" tf:"config_map,omitempty"`

	// (Block Set) A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM. (see below for nested schema)
	// A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM.
	ContainerDisk []ContainerDiskInitParameters `json:"containerDisk,omitempty" tf:"container_disk,omitempty"`

	// (Block List, Max: 1) DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image. (see below for nested schema)
	// DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image.
	DataVolume []DataVolumeInitParameters `json:"dataVolume,omitempty" tf:"data_volume,omitempty"`

	// (Block List, Max: 1) EmptyDisk represents a temporary disk which shares the VM's lifecycle. (see below for nested schema)
	// EmptyDisk represents a temporary disk which shares the VM's lifecycle.
	EmptyDisk []EmptyDiskInitParameters `json:"emptyDisk,omitempty" tf:"empty_disk,omitempty"`

	// (Block List, Max: 1) EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling. (see below for nested schema)
	// EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling.
	Ephemeral []EphemeralInitParameters `json:"ephemeral,omitempty" tf:"ephemeral,omitempty"`

	// (Block List, Max: 1) HostDisk represents a disk created on the host. (see below for nested schema)
	// HostDisk represents a disk created on the host.
	HostDisk []HostDiskInitParameters `json:"hostDisk,omitempty" tf:"host_disk,omitempty"`

	// (Block List, Max: 1) PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. (see below for nested schema)
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	PersistentVolumeClaim []VolumeSourcePersistentVolumeClaimInitParameters `json:"persistentVolumeClaim,omitempty" tf:"persistent_volume_claim,omitempty"`

	// (Block List, Max: 1) ServiceAccountVolumeSource represents a reference to a service account. (see below for nested schema)
	// ServiceAccountVolumeSource represents a reference to a service account.
	ServiceAccount []ServiceAccountInitParameters `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
}

type VolumeSourceObservation struct {

	// init Config Drive user-data source. (see below for nested schema)
	// CloudInitConfigDrive represents a cloud-init Config Drive user-data source.
	CloudInitConfigDrive []CloudInitConfigDriveObservation `json:"cloudInitConfigDrive,omitempty" tf:"cloud_init_config_drive,omitempty"`

	// init noCloud image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init noCloud image and used as the disk for the VM (see below for nested schema)
	// Used to specify a cloud-init `noCloud` image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init `noCloud `image and used as the disk for the VM
	CloudInitNoCloud []CloudInitNoCloudObservation `json:"cloudInitNoCloud,omitempty" tf:"cloud_init_no_cloud,omitempty"`

	// (Block List, Max: 1) ConfigMapVolumeSource adapts a ConfigMap into a volume. (see below for nested schema)
	// ConfigMapVolumeSource adapts a ConfigMap into a volume.
	ConfigMap []ConfigMapObservation `json:"configMap,omitempty" tf:"config_map,omitempty"`

	// (Block Set) A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM. (see below for nested schema)
	// A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM.
	ContainerDisk []ContainerDiskObservation `json:"containerDisk,omitempty" tf:"container_disk,omitempty"`

	// (Block List, Max: 1) DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image. (see below for nested schema)
	// DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image.
	DataVolume []DataVolumeObservation `json:"dataVolume,omitempty" tf:"data_volume,omitempty"`

	// (Block List, Max: 1) EmptyDisk represents a temporary disk which shares the VM's lifecycle. (see below for nested schema)
	// EmptyDisk represents a temporary disk which shares the VM's lifecycle.
	EmptyDisk []EmptyDiskObservation `json:"emptyDisk,omitempty" tf:"empty_disk,omitempty"`

	// (Block List, Max: 1) EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling. (see below for nested schema)
	// EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling.
	Ephemeral []EphemeralObservation `json:"ephemeral,omitempty" tf:"ephemeral,omitempty"`

	// (Block List, Max: 1) HostDisk represents a disk created on the host. (see below for nested schema)
	// HostDisk represents a disk created on the host.
	HostDisk []HostDiskObservation `json:"hostDisk,omitempty" tf:"host_disk,omitempty"`

	// (Block List, Max: 1) PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. (see below for nested schema)
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	PersistentVolumeClaim []VolumeSourcePersistentVolumeClaimObservation `json:"persistentVolumeClaim,omitempty" tf:"persistent_volume_claim,omitempty"`

	// (Block List, Max: 1) ServiceAccountVolumeSource represents a reference to a service account. (see below for nested schema)
	// ServiceAccountVolumeSource represents a reference to a service account.
	ServiceAccount []ServiceAccountObservation `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
}

type VolumeSourceParameters struct {

	// init Config Drive user-data source. (see below for nested schema)
	// CloudInitConfigDrive represents a cloud-init Config Drive user-data source.
	// +kubebuilder:validation:Optional
	CloudInitConfigDrive []CloudInitConfigDriveParameters `json:"cloudInitConfigDrive,omitempty" tf:"cloud_init_config_drive,omitempty"`

	// init noCloud image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init noCloud image and used as the disk for the VM (see below for nested schema)
	// Used to specify a cloud-init `noCloud` image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init `noCloud `image and used as the disk for the VM
	// +kubebuilder:validation:Optional
	CloudInitNoCloud []CloudInitNoCloudParameters `json:"cloudInitNoCloud,omitempty" tf:"cloud_init_no_cloud,omitempty"`

	// (Block List, Max: 1) ConfigMapVolumeSource adapts a ConfigMap into a volume. (see below for nested schema)
	// ConfigMapVolumeSource adapts a ConfigMap into a volume.
	// +kubebuilder:validation:Optional
	ConfigMap []ConfigMapParameters `json:"configMap,omitempty" tf:"config_map,omitempty"`

	// (Block Set) A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM. (see below for nested schema)
	// A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM.
	// +kubebuilder:validation:Optional
	ContainerDisk []ContainerDiskParameters `json:"containerDisk,omitempty" tf:"container_disk,omitempty"`

	// (Block List, Max: 1) DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image. (see below for nested schema)
	// DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image.
	// +kubebuilder:validation:Optional
	DataVolume []DataVolumeParameters `json:"dataVolume,omitempty" tf:"data_volume,omitempty"`

	// (Block List, Max: 1) EmptyDisk represents a temporary disk which shares the VM's lifecycle. (see below for nested schema)
	// EmptyDisk represents a temporary disk which shares the VM's lifecycle.
	// +kubebuilder:validation:Optional
	EmptyDisk []EmptyDiskParameters `json:"emptyDisk,omitempty" tf:"empty_disk,omitempty"`

	// (Block List, Max: 1) EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling. (see below for nested schema)
	// EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling.
	// +kubebuilder:validation:Optional
	Ephemeral []EphemeralParameters `json:"ephemeral,omitempty" tf:"ephemeral,omitempty"`

	// (Block List, Max: 1) HostDisk represents a disk created on the host. (see below for nested schema)
	// HostDisk represents a disk created on the host.
	// +kubebuilder:validation:Optional
	HostDisk []HostDiskParameters `json:"hostDisk,omitempty" tf:"host_disk,omitempty"`

	// (Block List, Max: 1) PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. (see below for nested schema)
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	// +kubebuilder:validation:Optional
	PersistentVolumeClaim []VolumeSourcePersistentVolumeClaimParameters `json:"persistentVolumeClaim,omitempty" tf:"persistent_volume_claim,omitempty"`

	// (Block List, Max: 1) ServiceAccountVolumeSource represents a reference to a service account. (see below for nested schema)
	// ServiceAccountVolumeSource represents a reference to a service account.
	// +kubebuilder:validation:Optional
	ServiceAccount []ServiceAccountParameters `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
}

type VolumeSourcePersistentVolumeClaimInitParameters struct {

	// volumes#persistentvolumeclaims
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName *string `json:"claimName,omitempty" tf:"claim_name,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type VolumeSourcePersistentVolumeClaimObservation struct {

	// volumes#persistentvolumeclaims
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName *string `json:"claimName,omitempty" tf:"claim_name,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type VolumeSourcePersistentVolumeClaimParameters struct {

	// volumes#persistentvolumeclaims
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +kubebuilder:validation:Optional
	ClaimName *string `json:"claimName" tf:"claim_name,omitempty"`

	// (Boolean) ReadOnly. Defaults to false.
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

// MachineSpec defines the desired state of Machine
type MachineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MachineParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MachineInitParameters `json:"initProvider,omitempty"`
}

// MachineStatus defines the observed state of Machine.
type MachineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MachineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Machine is the Schema for the Machines API.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,palette}
type Machine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterUid) || (has(self.initProvider) && has(self.initProvider.clusterUid))",message="spec.forProvider.clusterUid is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.resources) || (has(self.initProvider) && has(self.initProvider.resources))",message="spec.forProvider.resources is a required parameter"
	Spec   MachineSpec   `json:"spec"`
	Status MachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MachineList contains a list of Machines
type MachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Machine `json:"items"`
}

// Repository type metadata.
var (
	Machine_Kind             = "Machine"
	Machine_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Machine_Kind}.String()
	Machine_KindAPIVersion   = Machine_Kind + "." + CRDGroupVersion.String()
	Machine_GroupVersionKind = CRDGroupVersion.WithKind(Machine_Kind)
)

func init() {
	SchemeBuilder.Register(&Machine{}, &MachineList{})
}
